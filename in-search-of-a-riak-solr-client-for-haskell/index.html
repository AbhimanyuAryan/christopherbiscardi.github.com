<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" type="text/css" href="/styles.df72ee54210722a4ff300245e06a1b05.css"/></head><body class="landing-page"><div id="react-mount"><div data-reactid=".mbnvbwcu80" data-react-checksum="-1034338494"><div class="Nav__wrapper___u7BUA" data-reactid=".mbnvbwcu80.0"><nav class="Nav__nav___1e2Pp" data-reactid=".mbnvbwcu80.0.0"><div class="Nav__logoWrapper___35yvY" data-reactid=".mbnvbwcu80.0.0.0"><img class="Nav__logo___sw4O9" src="0576ff3991e0305da5b886052adbc044.png" data-reactid=".mbnvbwcu80.0.0.0.0"/></div><ul class="Nav__items___1oDCD" data-reactid=".mbnvbwcu80.0.0.1"><li data-reactid=".mbnvbwcu80.0.0.1.0"><a class="Nav__itemLink___H6Isv" href="/posts" data-reactid=".mbnvbwcu80.0.0.1.0.0">Posts</a></li><li data-reactid=".mbnvbwcu80.0.0.1.1"><a class="Nav__itemLink___H6Isv" href="/talks" data-reactid=".mbnvbwcu80.0.0.1.1.0">Talks</a></li><li data-reactid=".mbnvbwcu80.0.0.1.2"><a class="Nav__itemLink___H6Isv" href="/books" data-reactid=".mbnvbwcu80.0.0.1.2.0">Books</a></li><li data-reactid=".mbnvbwcu80.0.0.1.3"><a class="Nav__itemLink___H6Isv" href="/projects" data-reactid=".mbnvbwcu80.0.0.1.3.0">Projects</a></li></ul></nav></div><div data-reactid=".mbnvbwcu80.1"><div data-reactid=".mbnvbwcu80.1.0"><p>In this post are the beginnings of riak-solr-client.</p>
<p>First, we need to take a look at the response from Solr/Yokozuna/Riak-Search-2 for a single query. In this case, the database only holds two records and we are doing a query that matches all results (<code>*:*</code>).</p>
<pre><code>&lt;code <span class="hljs-built_in">class</span>=<span class="hljs-string">"JavaScript"</span>&gt;{
   <span class="hljs-string">"responseHeader"</span>:{
      <span class="hljs-string">"status"</span>:<span class="hljs-number">0</span>,
      <span class="hljs-string">"QTime"</span>:<span class="hljs-number">11</span>,
      <span class="hljs-string">"params"</span>:{
         <span class="hljs-string">"shards"</span>:<span class="hljs-string">"127.0.0.1:8093/solr/my_index"</span>,
         <span class="hljs-string">"q"</span>:<span class="hljs-string">"*:*"</span>,
         <span class="hljs-string">"127.0.0.1:8093"</span>:<span class="hljs-string">"_yz_pn:64 OR (_yz_pn:61 AND (_yz_fpn:61)) OR _yz_pn:60 OR _yz_pn:57 OR _yz_pn:54 OR _yz_pn:51 OR _yz_pn:48 OR _yz_pn:45 OR _yz_pn:42 OR _yz_pn:39 OR _yz_pn:36 OR _yz_pn:33 OR _yz_pn:30 OR _yz_pn:27 OR _yz_pn:24 OR _yz_pn:21 OR _yz_pn:18 OR _yz_pn:15 OR _yz_pn:12 OR _yz_pn:9 OR _yz_pn:6 OR _yz_pn:3"</span>,
         <span class="hljs-string">"wt"</span>:<span class="hljs-string">"json"</span>
      }
   },
   <span class="hljs-string">"response"</span>:{
      <span class="hljs-string">"numFound"</span>:<span class="hljs-number">2</span>,
      <span class="hljs-string">"start"</span>:<span class="hljs-number">0</span>,
      <span class="hljs-string">"maxScore"</span>:<span class="hljs-number">1.0</span>,
      <span class="hljs-string">"docs"</span>:[
         {
            <span class="hljs-string">"_yz_id"</span>:<span class="hljs-string">"data_my_bucket_name_12"</span>,
            <span class="hljs-string">"_yz_rk"</span>:<span class="hljs-string">"name"</span>,
            <span class="hljs-string">"_yz_rt"</span>:<span class="hljs-string">"data"</span>,
            <span class="hljs-string">"_yz_rb"</span>:<span class="hljs-string">"my_bucket"</span>
         },
         {
            <span class="hljs-string">"_yz_id"</span>:<span class="hljs-string">"data_my_bucket_second_15"</span>,
            <span class="hljs-string">"_yz_rk"</span>:<span class="hljs-string">"second"</span>,
            <span class="hljs-string">"_yz_rt"</span>:<span class="hljs-string">"data"</span>,
            <span class="hljs-string">"_yz_rb"</span>:<span class="hljs-string">"my_bucket"</span>
         }
      ]
   }
}```

As you can see, I’ve decided <span class="hljs-keyword">to</span> retrieve JSON because <span class="hljs-keyword">of</span> <span class="hljs-keyword">my</span> familiarity <span class="hljs-keyword">with</span> Data.Aeson. There <span class="hljs-keyword">is</span> no <span class="hljs-keyword">set</span> schema <span class="hljs-keyword">for</span> Solr responses, so we’re going <span class="hljs-keyword">to</span> have <span class="hljs-keyword">to</span> test this fairly well <span class="hljs-keyword">to</span> make a generic library <span class="hljs-keyword">that</span> will be updated <span class="hljs-keyword">over</span> <span class="hljs-built_in">time</span> <span class="hljs-keyword">as</span> Solr updates.

With <span class="hljs-keyword">the</span> sample response <span class="hljs-keyword">in</span> mind, we can start <span class="hljs-keyword">to</span> create <span class="hljs-keyword">the</span> datatypes:

</code></pre>
<p><code class="haskell">newtype Params = Params (Map String String) deriving (Show)</p>
<p>data ResponseHeader = ResponseHeader {
status :: Int,
qTime  :: Int,
params :: Params
} deriving (Show)</p>
<p>data Docs = Docs {
_yz_id :: String,
_yz_rk :: String,
_yz_rt :: String,
_yz_rb :: String
} deriving (Show)</p>
<p>data Results = Results {
numFound :: Int,
start :: Int,
maxScore :: Float,
docs :: [Docs]
} deriving (Show)</p>
<p>data SolrResponse = SolrResponse {
responseHeader :: ResponseHeader,
response :: Results
} deriving (Show)```</p>
<p>The most interesting part of this is <code>Params</code>. We’ve defined <code>Params</code> as a <code>newtype</code> for a <code>Data.Map</code> because, making an educated guess, the keys for params won’t always be the same. We can reach this conclusion by seeing that one of the keys is an IP address (with a port number).</p>
<p>Another interesting piece of the response is the <code>Docs</code>. Solr seems to return the id in Solr (<code>_yz</code> is presumably for _yokozuna), the Riak Key (<code>_yz_rk</code>), the Riak Bucket Type <code>_yz_rt</code> and the Riak Bucket (<code>_yz_rb</code>). This is useful information because we will need to use riak-haskell-client (or more likely an updated fork for Riak 2.0) to retrieve the actual data.</p>
<p>We can now write some JSON instances and basic http code to test. Here is the full file:</p>
<pre><code>&lt;code <span class="hljs-keyword">class</span>=<span class="hljs-string">"haskell"</span> style=<span class="hljs-string">"overflow-x:scroll"</span>&gt;<span class="hljs-meta">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="hljs-keyword">import</span> Data.Aeson
<span class="hljs-keyword">import</span> Data.Map
<span class="hljs-keyword">import</span> Control.Applicative
<span class="hljs-keyword">import</span> Control.Monad (<span class="hljs-title">mzero</span>)

<span class="hljs-keyword">import</span> Network.HTTP.Conduit <span class="hljs-comment">-- the main module</span>

<span class="hljs-comment">-- The streaming interface uses conduits</span>
<span class="hljs-keyword">import</span> Data.Conduit
<span class="hljs-keyword">import</span> Data.Conduit.Binary (<span class="hljs-title">sinkFile</span>)

<span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.ByteString.Lazy.Char8 <span class="hljs-keyword">as</span> L
<span class="hljs-keyword">import</span> Control.Monad.IO.Class (<span class="hljs-title">liftIO</span>)

<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Params</span> = <span class="hljs-type">Params</span> (<span class="hljs-type">Map</span> <span class="hljs-type">String</span> <span class="hljs-type">String</span>) <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">FromJSON</span> <span class="hljs-type">Params</span> <span class="hljs-keyword">where</span></span>
  parseJSON val = <span class="hljs-type">Params</span>  parseJSON val

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ResponseHeader</span> = <span class="hljs-type">ResponseHeader</span> {
  <span class="hljs-title">status</span> :: <span class="hljs-type">Int</span>,
  <span class="hljs-title">qTime</span>  :: <span class="hljs-type">Int</span>,
  <span class="hljs-title">params</span> :: <span class="hljs-type">Params</span>
} <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">FromJSON</span> <span class="hljs-type">ResponseHeader</span> <span class="hljs-keyword">where</span></span>
  parseJSON (<span class="hljs-type">Object</span> o) = <span class="hljs-type">ResponseHeader</span>  o .: <span class="hljs-string">"status"</span>
                                         o .: <span class="hljs-string">"QTime"</span>
                                         o .: <span class="hljs-string">"params"</span>
  parseJSON _ = mzero

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Docs</span> = <span class="hljs-type">Docs</span> {
  <span class="hljs-title">_yz_id</span> :: <span class="hljs-type">String</span>,
  <span class="hljs-title">_yz_rk</span> :: <span class="hljs-type">String</span>,
  <span class="hljs-title">_yz_rt</span> :: <span class="hljs-type">String</span>,
  <span class="hljs-title">_yz_rb</span> :: <span class="hljs-type">String</span>
} <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">FromJSON</span> <span class="hljs-type">Docs</span> <span class="hljs-keyword">where</span></span>
  parseJSON (<span class="hljs-type">Object</span> o) = <span class="hljs-type">Docs</span>  o .: <span class="hljs-string">"_yz_id"</span>
                               o .: <span class="hljs-string">"_yz_rk"</span>
                               o .: <span class="hljs-string">"_yz_rt"</span>
                               o .: <span class="hljs-string">"_yz_rb"</span>
  parseJSON _ = mzero   

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Results</span> = <span class="hljs-type">Results</span> {
  <span class="hljs-title">numFound</span> :: <span class="hljs-type">Int</span>,
  <span class="hljs-title">start</span> :: <span class="hljs-type">Int</span>,
  <span class="hljs-title">maxScore</span> :: <span class="hljs-type">Float</span>,
  <span class="hljs-title">docs</span> :: [<span class="hljs-type">Docs</span>]
} <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">FromJSON</span> <span class="hljs-type">Results</span> <span class="hljs-keyword">where</span></span>
  parseJSON (<span class="hljs-type">Object</span> o) = <span class="hljs-type">Results</span>  o .: <span class="hljs-string">"numFound"</span>
                                  o .: <span class="hljs-string">"start"</span>
                                  o .: <span class="hljs-string">"maxScore"</span>
                                  o .: <span class="hljs-string">"docs"</span>
  parseJSON _ = mzero

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">SolrResponse</span> = <span class="hljs-type">SolrResponse</span> {
  <span class="hljs-title">responseHeader</span> :: <span class="hljs-type">ResponseHeader</span>,
  <span class="hljs-title">response</span> :: <span class="hljs-type">Results</span>
} <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">FromJSON</span> <span class="hljs-type">SolrResponse</span> <span class="hljs-keyword">where</span></span>
  parseJSON (<span class="hljs-type">Object</span> o) = <span class="hljs-type">SolrResponse</span>  o .: <span class="hljs-string">"responseHeader"</span>
                                       o .: <span class="hljs-string">"response"</span>
  parseJSON _ = mzero

<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
</code></pre>
<p>and running <code>main</code> in ghci gives us:</p>
<p><code>&lt;code class=&quot;haskell&quot;&gt;Just (SolrResponse {responseHeader = ResponseHeader {status = 0, qTime = 8, params = Params (fromList [(&quot;127.0.0.1:8093&quot;,&quot;_yz_pn:63 OR (_yz_pn:60 AND (_yz_fpn:60)) OR _yz_pn:59 OR _yz_pn:56 OR _yz_pn:53 OR _yz_pn:50 OR _yz_pn:47 OR _yz_pn:44 OR _yz_pn:41 OR _yz_pn:38 OR _yz_pn:35 OR _yz_pn:32 OR _yz_pn:29 OR _yz_pn:26 OR _yz_pn:23 OR _yz_pn:20 OR _yz_pn:17 OR _yz_pn:14 OR _yz_pn:11 OR _yz_pn:8 OR _yz_pn:5 OR _yz_pn:2&quot;),(&quot;q&quot;,&quot;*:*&quot;),(&quot;shards&quot;,&quot;127.0.0.1:8093/solr/my_index&quot;),(&quot;wt&quot;,&quot;json&quot;)])}, response = Results {numFound = 2, start = 0, maxScore = 1.0, docs = [Docs {_yz_id = &quot;data_my_bucket_name_11&quot;, _yz_rk = &quot;name&quot;, _yz_rt = &quot;data&quot;, _yz_rb = &quot;my_bucket&quot;},Docs {_yz_id = &quot;data_my_bucket_second_14&quot;, _yz_rk = &quot;second&quot;, _yz_rt = &quot;data&quot;, _yz_rb = &quot;my_bucket&quot;}]}})</code></p>
<p>Success!</p>
<p>This is just a small start. Hopefully I’ll be able to build this out a bit more (two changes of note will be usage of <code>http-streams</code> and <code>Lens</code>) and write a snaplet that integrates well with <a href="https://github.com/ChristopherBiscardi/snaplet-riak-2">this Riak Snaplet</a> in a more generic fashion.</p>
</div></div></div></div><script src="/js/bundle-72c0db642ea1de5f23b8.js"></script></body></html>