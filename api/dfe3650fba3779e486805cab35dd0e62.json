{"data":{"post":{"body":"<p>Today I was trying to extract the minimal imports for a module using <code>ghc -ddump-minimal-imports</code> but I was getting this error on some files:</p>\n<pre><code>&lt;code class=<span class=\"hljs-string\">\"bash\"</span>&gt;error: missing binary operator <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">token</span> <span class=\"hljs-string\">\"(\"</span>\n<span class=\"hljs-comment\">#if MIN_VERSION_base(4,4,0)</span>\n^```\n\nWhich is related <span class=\"hljs-built_in\">to</span> <span class=\"hljs-keyword\">the</span> fact that `cabal` expands `MIN_VERSION_base` macros when running `cabal build`, so we don’t have them when running `ghc` <span class=\"hljs-keyword\">or</span> `ghci`. Luckily <span class=\"hljs-keyword\">it</span>’s <span class=\"hljs-keyword\">an</span> easy fix.\n\nCabal generates <span class=\"hljs-keyword\">a</span> macros <span class=\"hljs-built_in\">file</span> <span class=\"hljs-built_in\">relative</span> <span class=\"hljs-built_in\">to</span> <span class=\"hljs-keyword\">the</span> root <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> project <span class=\"hljs-keyword\">at</span> `dist/build/autogen/cabal_macros.h`. We can <span class=\"hljs-built_in\">include</span> this <span class=\"hljs-built_in\">file</span> <span class=\"hljs-built_in\">to</span> gain access <span class=\"hljs-built_in\">to</span> <span class=\"hljs-keyword\">the</span> macros:\n\n`&lt;code class=<span class=\"hljs-string\">\"bash\"</span> style=<span class=\"hljs-string\">\"overflow-x:auto\"</span>&gt;ghc -ddump-minimal-imports -optP-<span class=\"hljs-built_in\">include</span> -optPdist/build/autogen/cabal_macros.h src/Types.hs`\n\nWhich will now spit out our imports <span class=\"hljs-keyword\">into</span> <span class=\"hljs-keyword\">a</span> <span class=\"hljs-built_in\">file</span> called `Types.imports` <span class=\"hljs-keyword\">and</span> may look something like this:\n\n</code></pre>\n<p><code class=\"haskell\">import Blaze.ByteString.Builder\n( Builder, fromLazyByteString, fromByteString )\nimport Blaze.ByteString.Builder.Char.Utf8\n( fromText, fromLazyText )\nimport Control.Applicative\n( Applicative((), pure), Alternative((), empty), () )\nimport Control.Exception.Lifted\n( ErrorCall(…),\nException,\nHandler(…),\nSomeException(…),\ncatch,\ncatches,\nmask,\nonException,\nthrowIO )```</p>\n"}}}