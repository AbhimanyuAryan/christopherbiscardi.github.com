{"data":{"post":{"body":"<p>In a thread on HN recently there was a prompt:</p>\n<blockquote>\n<p>Read in a file full of numbers, one number on each line<br>\nRepresent those numbers as integers in your program<br>\nReplace each number with that number times its line number<br>\nWrite the file out elsewhere<br>\nAnd complete the task right now at your computer as fast as possible, you’re being timed</p>\n</blockquote>\n<p>Ignoring the spurious nature of the comment (and ignoring the benefits/drawbacks of interview-programming in general) there were a few responses:</p>\n<p>Consider this file for the responses:</p>\n<pre><code>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n</code></pre>\n<h2>Python</h2>\n<p>First, a sys-admin style Python script:</p>\n<p>It considers lines to be 0-based. (the first line is line 0) and accepts a file as an argument.</p>\n<pre><code>&lt;code <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">\"python\"</span>&gt;#!<span class=\"hljs-regexp\">/usr/</span>bin/python\n<span class=\"hljs-keyword\">import</span> sys\n<span class=\"hljs-keyword\">with</span> open(sys.argv[<span class=\"hljs-number\">1</span>]) <span class=\"hljs-keyword\">as</span> f:\n    <span class=\"hljs-keyword\">for</span> l, i <span class=\"hljs-keyword\">in</span> enumerate(f):\n        print l * int(i)\n</code></pre>\n<p>Pretty nice overall and gives this result:</p>\n<pre><code>2\n6\n12\n20\n30\n42\n56\n72\n90\n</code></pre>\n<h2>awk</h2>\n<p>The next was awk-based:</p>\n<p><code>&lt;code class=&quot;bash&quot;&gt;awk '{print $0 * NR}' nums.txt &gt; output</code></p>\n<p>Very succinct. Probably the shortest (most powerful if you subscribe to that idea) response and very efficient for this use case (doubling numbers based on lines). It gives this output:</p>\n<pre><code><span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">9</span>\n<span class=\"hljs-number\">16</span>\n<span class=\"hljs-number\">25</span>\n<span class=\"hljs-number\">36</span>\n<span class=\"hljs-number\">49</span>\n<span class=\"hljs-number\">64</span>\n<span class=\"hljs-number\">81</span>\n<span class=\"hljs-number\">100</span>```\n\n\n<span class=\"hljs-comment\">## node.js</span>\n\nNext up, <span class=\"hljs-keyword\">node</span>.js:<span class=\"hljs-title\">\n\n</span></code></pre>\n<p><code class=\"javascript\">var fs = require(‘fs’);\nvar lines = fs.readFileSync(’./nums.txt’,‘utf8’)\n.trim().split(/\\r\\n|\\r|\\n/g);\nfor (var i=0; i&lt;lines.length; i++) {\nlines[i] = i * +lines[i];\n}\nfs.writeFileSync(\n’./outfile.txt’\n,‘utf8’\n,lines.join(’\\n’)\n);</p>\n<pre><code>\nWhich works, but chokes when writing <span class=\"hljs-keyword\">the</span> <span class=\"hljs-built_in\">file</span> back out. Arguably reading/writing <span class=\"hljs-built_in\">files</span> is more <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">a</span> strength <span class=\"hljs-keyword\">for</span> python/(bash/awk). There are many ways <span class=\"hljs-built_in\">to</span> <span class=\"hljs-built_in\">write</span> this code <span class=\"hljs-keyword\">in</span> js, so we’ll just skip <span class=\"hljs-built_in\">to</span> <span class=\"hljs-keyword\">the</span> output.\n\n</code></pre>\n<p>fs.js:113\nthrow new Error('Unknown encoding: ’ + encoding);\n^\nError: Unknown encoding: 0\n2\n6\n12\n20\n30\n42\n56\n72\n90\nat assertEncoding (fs.js:113:11)\nat Object.fs.writeFileSync (fs.js:963:3)\nat Object.<anonymous> (/Users/chris/Desktop/haskell/nums.js:7:4)\nat Module._compile (module.js:456:26)\nat Object.Module._extensions…js (module.js:474:10)\nat Module.load (module.js:356:32)\nat Function.Module._load (module.js:312:12)\nat Function.Module.runMain (module.js:497:10)\nat startup (node.js:119:16)\nat node.js:901:3</anonymous>```</p>\n<h2>Haskell</h2>\n<p>Next up, a Haskell implementation:</p>\n<pre><code>&lt;code <span class=\"hljs-built_in\">class</span>=<span class=\"hljs-string\">\"haskell\"</span> style=<span class=\"hljs-string\">\"overflow-x:scroll\"</span>&gt;import Data.List\n\nmain :: IO ()\nmain = writeListAsLines . toDoubleList . lines =```\n\nThis <span class=\"hljs-keyword\">is</span> probably similar <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">the</span> code I would've written <span class=\"hljs-keyword\">in</span> an interview environment. It can be cleaned up a bit fairly trivially though <span class=\"hljs-keyword\">with</span> `unlines` (which I somehow forgot <span class=\"hljs-keyword\">about</span>, <span class=\"hljs-keyword\">then</span> remembered <span class=\"hljs-keyword\">as</span> I was <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">my</span> way <span class=\"hljs-keyword\">to</span> lunch):\n\n</code></pre>\n<p><code class=\"haskell\" style=\"overflow-x:scroll\">import Data.List</p>\n<p>main :: IO ()\nmain = writeListAsLines . toDoubleList . lines =```</p>\n<p>or split up (maybe a little pathologically if you aren’t particularly happy with interview coding) to see the type signatures on everything.</p>\n<pre><code>&lt;code class=<span class=\"hljs-string\">\"haskell\"</span> style=<span class=\"hljs-string\">\"overflow-x:scroll\"</span>&gt;<span class=\"hljs-keyword\">import</span> Data.List\n\nmain <span class=\"hljs-type\">::</span> <span class=\"hljs-built_in\">IO</span> ()\nmain = doubleIntsInFile <span class=\"hljs-string\">\"nums.txt\"</span> <span class=\"hljs-string\">\"numsout.txt\"</span>\n\ndoubleIntsInFile <span class=\"hljs-type\">::</span> FilePath -&gt; FilePath -&gt; <span class=\"hljs-built_in\">IO</span> ()\ndoubleIntsInFile inFile out = writeDoubled out = <span class=\"hljs-built_in\">String</span> -&gt; <span class=\"hljs-built_in\">IO</span> ()\nwriteDoubled x = writeListAsLines x . toDoubleList . lines\n\ntoDoubleList <span class=\"hljs-type\">::</span> [<span class=\"hljs-built_in\">String</span>] -&gt; [<span class=\"hljs-built_in\">Int</span>]\ntoDoubleList y = zipWith (*) (map read y) [<span class=\"hljs-number\">1.</span>.length y]\n\nwriteListAsLines <span class=\"hljs-type\">::</span> <span class=\"hljs-built_in\">String</span> -&gt; [<span class=\"hljs-built_in\">Int</span>] -&gt; <span class=\"hljs-built_in\">IO</span> ()\nwriteListAsLines fl =  writeFile fl . mkString\n\nmkString <span class=\"hljs-type\">::</span> [<span class=\"hljs-built_in\">Int</span>] -&gt; <span class=\"hljs-built_in\">String</span>\nmkString = unlines . map show\n</code></pre>\n<p>and the output:</p>\n<pre><code>1\n4\n9\n16\n25\n36\n49\n64\n81\n100<span class=\"hljs-code\">```</span>\n\n\n<span class=\"hljs-section\">## Conclusion</span>\n\nDraw your own. My opinion is that AWK is the best tool for this odd job with Python a close second. (When observing these answers).\n\nFeel like code golfing a bit? Post an answer in the comments.\n\n\n<span class=\"hljs-section\"># Update</span>\n\n\n<span class=\"hljs-section\">## Perl</span>\n\nPerl was added by [<span class=\"hljs-string\">David Baker</span>](<span class=\"hljs-link\">https://plus.google.com/u/0/+DavidBakerNYC/posts</span>) on the [<span class=\"hljs-string\">Google+ thread</span>](<span class=\"hljs-link\">https://plus.google.com/u/0/104488078938246881552/posts/Uzsf6qrRMns</span>).\n\n<span class=\"hljs-code\">`&lt;code class=\"perl\"&gt;perl -lne 'print $_ * $.' `</span>\n\nIt is approximately the same level as the previous awk script and a pretty easy to understand.\n\n</code></pre>\n<p>1\n4\n9\n16\n25\n36\n49\n64\n81\n100```</p>\n"}}}