{"data":{"root":{"post":{"body":"<h2 id=\"prerequisites\">Prerequisites</h2>\n<dl><dt>[Rebar](https://github.com/basho/rebar)</dt><dd>To build the project</dd></dl>\n##  Relevant Files\n<dl><dt>Project on Github</dt><dd>[https://github.com/ChristopherBiscardi/Riak-Core-Consistent-Hash-Routing-Example](https://github.com/ChristopherBiscardi/Riak-Core-Consistent-Hash-Routing-Example)</dd><dt>[chapp.erl](https://github.com/ChristopherBiscardi/Riak-Core-Consistent-Hash-Routing-Example/blob/master/a    pps/chapp/src/chapp.erl)</dt><dd>Holds the different routing code</dd><dt>[chapp_vnode.erl](https://github.com/ChristopherBiscardi/Riak-Core-Consistent-Hash-Routing-Example/blob/master/apps/chapp/src    /chapp_vnode.erl)</dt><dd>The ping function on the vnodes. This function is the same on every vnode, the difference is which vnode is processing the request.</dd></dl>\n<h2 id=\"the-code\">The Code</h2>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"highlight__hljs-comment___UYk12\">%% @doc Pings a random vnode</span>\n<span class=\"hljs-function\"><span class=\"highlight__hljs-title___1fl8Q\">ping</span><span class=\"hljs-params\">()</span> -&gt;</span>\n    DocIdx = riak_core_util:chash_key({&gt;, term_to_binary(now())}),\n    PrefList = riak_core_apl:get_primary_apl(DocIdx, <span class=\"highlight__hljs-number___2gmaH\">1</span>, chapp),\n    [{IndexNode, _Type}] = PrefList,\n    riak_core_vnode_master:sync_spawn_command(IndexNode, ping, chapp_vnode_master).\n</code></pre>\n<p>The first function, shown above, pings a random (random enough for our purposes)\nvnode and returns the partition identifier. The code we’re interested in is in\nthe first line of the function – specifically the chash_key() function.</p>\n<p>The\n<a href=\"https://github.com/basho/riak_core/blob/master/src/riak_core_util.erl#L187-192\">chash_key</a>\nfunction takes a two-tuple and returns a binary identifier we can use to get a\nPrefList. Much of the terminology in the Riak Core source refers to Riak KV. In\nthis case, the variables are named Bucket and Key in the chash_key function.</p>\n<p>Each function in\n[chapp.erl](<a href=\"https://github.com/ChristopherBiscardi/Riak-Core-Consistent-Hash-Routing-Example/blob/master/a\">https://github.com/ChristopherBiscardi/Riak-Core-Consistent-Hash-Routing-Example/blob/master/a</a>\npps/chapp/src/chapp.erl) has different tuples which affect which vnode gets\ncalled.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"highlight__hljs-comment___UYk12\">% ping()</span>\n{&gt;, term_to_binary(now())}\n\n<span class=\"highlight__hljs-comment___UYk12\">% pingsame()</span>\n{&gt;, &gt;}\n\n<span class=\"highlight__hljs-comment___UYk12\">% pinginput(X)</span>\n{&gt;, term_to_binary(X)}\n</code></pre>\n<p>so if we build the project.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"highlight__hljs-built_in___3uuyR\">cd</span> path/to/project\nmake rel\n</code></pre>\n<p>and run the console</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code>./rel/chapp/bin/chapp console\n</code></pre>\n<p>we can then execute the various ping() functions as such:</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code>chapp:ping().\n</code></pre>\n<p>which gives us a tuple that contains <code>pong</code> and the partition id that processed\nthe request.</p>\n<p>We can see the results from running the ping() function a couple times below.\nNotice that each time we run ping(), a different partition handles the call.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code>{pong,<span class=\"highlight__hljs-number___2gmaH\">1004782375664995756265033322492444576013453623296</span>}\n{pong,<span class=\"highlight__hljs-number___2gmaH\">1050454301831586472458898473514828420377701515264</span>}\n{pong,<span class=\"highlight__hljs-number___2gmaH\">1027618338748291114361965898003636498195577569280</span>}\n{pong,<span class=\"highlight__hljs-number___2gmaH\">1118962191081472546749696200048404186924073353216</span>}\n</code></pre>\n<p>Looking at the next function <code>pingsame</code> which we call as such:</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code>chapp:pingsame().\n</code></pre>\n<p>we can see that by calling this function multiple times, we get the same\npartition handling the call, because the hash of the tuple is always the same.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code>{pong,<span class=\"highlight__hljs-number___2gmaH\">936274486415109681974235595958868809467081785344</span>}\n{pong,<span class=\"highlight__hljs-number___2gmaH\">936274486415109681974235595958868809467081785344</span>}\n{pong,<span class=\"highlight__hljs-number___2gmaH\">936274486415109681974235595958868809467081785344</span>}\n{pong,<span class=\"highlight__hljs-number___2gmaH\">936274486415109681974235595958868809467081785344</span>}\n</code></pre>\n<p>The pinginput function allows us to take a more interactive look at where our\nrequests go. pinginput uses the input we give it as the second element in the\nchash_key function tuple.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code>chapp:pinginput(someinput).\n</code></pre>\n<p>we can see that by calling this function multiple times with the same input, the\nsame vnode processes the request.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code>chapp:pinginput(someinput).\n{pong,<span class=\"highlight__hljs-number___2gmaH\">959110449498405040071168171470060731649205731328</span>}\nchapp:pinginput(someinput).\n{pong,<span class=\"highlight__hljs-number___2gmaH\">959110449498405040071168171470060731649205731328</span>}\nchapp:pinginput(someinput).\n{pong,<span class=\"highlight__hljs-number___2gmaH\">959110449498405040071168171470060731649205731328</span>}\n</code></pre>\n<p>We can also see that by calling pinginput with a different input results in a\ndifferent vnode handling the request.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code>chapp:pinginput(otherinput).\n{pong,<span class=\"highlight__hljs-number___2gmaH\">342539446249430371453988632667878832731859189760</span>}\nchapp:pinginput(otherinput).\n{pong,<span class=\"highlight__hljs-number___2gmaH\">342539446249430371453988632667878832731859189760</span>}\nchapp:pinginput(otherinput).\n{pong,<span class=\"highlight__hljs-number___2gmaH\">342539446249430371453988632667878832731859189760</span>}\n</code></pre>\n","attributes":{"title":"Consistant Hash Routing in Riak Core","updatedAt":"Jan 16th, 2013","publishedAt":"Jan 16th, 2013","timeToRead":1,"headerImage":null,"url":"/2013/1/16/consistant-hash-routing-in-riak-core/","canonicalURL":null,"excerpt":"The first function, shown above, pings a random (random enough for our purposes)\nvnode and returns the partition identifier. The code we’re…","__typename":"BlogPostAttributes"},"__typename":"BlogPost"},"__typename":"Query"}}}