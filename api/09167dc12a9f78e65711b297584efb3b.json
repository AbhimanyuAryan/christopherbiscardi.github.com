{"data":{"post":{"body":"<p>In this post are the beginnings of riak-solr-client.</p>\n<p>First, we need to take a look at the response from Solr/Yokozuna/Riak-Search-2 for a single query. In this case, the database only holds two records and we are doing a query that matches all results (<code>*:*</code>).</p>\n<pre><code>&lt;code <span class=\"hljs-built_in\">class</span>=<span class=\"hljs-string\">\"JavaScript\"</span>&gt;{\n   <span class=\"hljs-string\">\"responseHeader\"</span>:{\n      <span class=\"hljs-string\">\"status\"</span>:<span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-string\">\"QTime\"</span>:<span class=\"hljs-number\">11</span>,\n      <span class=\"hljs-string\">\"params\"</span>:{\n         <span class=\"hljs-string\">\"shards\"</span>:<span class=\"hljs-string\">\"127.0.0.1:8093/solr/my_index\"</span>,\n         <span class=\"hljs-string\">\"q\"</span>:<span class=\"hljs-string\">\"*:*\"</span>,\n         <span class=\"hljs-string\">\"127.0.0.1:8093\"</span>:<span class=\"hljs-string\">\"_yz_pn:64 OR (_yz_pn:61 AND (_yz_fpn:61)) OR _yz_pn:60 OR _yz_pn:57 OR _yz_pn:54 OR _yz_pn:51 OR _yz_pn:48 OR _yz_pn:45 OR _yz_pn:42 OR _yz_pn:39 OR _yz_pn:36 OR _yz_pn:33 OR _yz_pn:30 OR _yz_pn:27 OR _yz_pn:24 OR _yz_pn:21 OR _yz_pn:18 OR _yz_pn:15 OR _yz_pn:12 OR _yz_pn:9 OR _yz_pn:6 OR _yz_pn:3\"</span>,\n         <span class=\"hljs-string\">\"wt\"</span>:<span class=\"hljs-string\">\"json\"</span>\n      }\n   },\n   <span class=\"hljs-string\">\"response\"</span>:{\n      <span class=\"hljs-string\">\"numFound\"</span>:<span class=\"hljs-number\">2</span>,\n      <span class=\"hljs-string\">\"start\"</span>:<span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-string\">\"maxScore\"</span>:<span class=\"hljs-number\">1.0</span>,\n      <span class=\"hljs-string\">\"docs\"</span>:[\n         {\n            <span class=\"hljs-string\">\"_yz_id\"</span>:<span class=\"hljs-string\">\"data_my_bucket_name_12\"</span>,\n            <span class=\"hljs-string\">\"_yz_rk\"</span>:<span class=\"hljs-string\">\"name\"</span>,\n            <span class=\"hljs-string\">\"_yz_rt\"</span>:<span class=\"hljs-string\">\"data\"</span>,\n            <span class=\"hljs-string\">\"_yz_rb\"</span>:<span class=\"hljs-string\">\"my_bucket\"</span>\n         },\n         {\n            <span class=\"hljs-string\">\"_yz_id\"</span>:<span class=\"hljs-string\">\"data_my_bucket_second_15\"</span>,\n            <span class=\"hljs-string\">\"_yz_rk\"</span>:<span class=\"hljs-string\">\"second\"</span>,\n            <span class=\"hljs-string\">\"_yz_rt\"</span>:<span class=\"hljs-string\">\"data\"</span>,\n            <span class=\"hljs-string\">\"_yz_rb\"</span>:<span class=\"hljs-string\">\"my_bucket\"</span>\n         }\n      ]\n   }\n}```\n\nAs you can see, I’ve decided <span class=\"hljs-keyword\">to</span> retrieve JSON because <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">my</span> familiarity <span class=\"hljs-keyword\">with</span> Data.Aeson. There <span class=\"hljs-keyword\">is</span> no <span class=\"hljs-keyword\">set</span> schema <span class=\"hljs-keyword\">for</span> Solr responses, so we’re going <span class=\"hljs-keyword\">to</span> have <span class=\"hljs-keyword\">to</span> test this fairly well <span class=\"hljs-keyword\">to</span> make a generic library <span class=\"hljs-keyword\">that</span> will be updated <span class=\"hljs-keyword\">over</span> <span class=\"hljs-built_in\">time</span> <span class=\"hljs-keyword\">as</span> Solr updates.\n\nWith <span class=\"hljs-keyword\">the</span> sample response <span class=\"hljs-keyword\">in</span> mind, we can start <span class=\"hljs-keyword\">to</span> create <span class=\"hljs-keyword\">the</span> datatypes:\n\n</code></pre>\n<p><code class=\"haskell\">newtype Params = Params (Map String String) deriving (Show)</p>\n<p>data ResponseHeader = ResponseHeader {\nstatus :: Int,\nqTime  :: Int,\nparams :: Params\n} deriving (Show)</p>\n<p>data Docs = Docs {\n_yz_id :: String,\n_yz_rk :: String,\n_yz_rt :: String,\n_yz_rb :: String\n} deriving (Show)</p>\n<p>data Results = Results {\nnumFound :: Int,\nstart :: Int,\nmaxScore :: Float,\ndocs :: [Docs]\n} deriving (Show)</p>\n<p>data SolrResponse = SolrResponse {\nresponseHeader :: ResponseHeader,\nresponse :: Results\n} deriving (Show)```</p>\n<p>The most interesting part of this is <code>Params</code>. We’ve defined <code>Params</code> as a <code>newtype</code> for a <code>Data.Map</code> because, making an educated guess, the keys for params won’t always be the same. We can reach this conclusion by seeing that one of the keys is an IP address (with a port number).</p>\n<p>Another interesting piece of the response is the <code>Docs</code>. Solr seems to return the id in Solr (<code>_yz</code> is presumably for _yokozuna), the Riak Key (<code>_yz_rk</code>), the Riak Bucket Type <code>_yz_rt</code> and the Riak Bucket (<code>_yz_rb</code>). This is useful information because we will need to use riak-haskell-client (or more likely an updated fork for Riak 2.0) to retrieve the actual data.</p>\n<p>We can now write some JSON instances and basic http code to test. Here is the full file:</p>\n<pre><code>&lt;code <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"haskell\"</span> style=<span class=\"hljs-string\">\"overflow-x:scroll\"</span>&gt;<span class=\"hljs-meta\">{-# LANGUAGE OverloadedStrings #-}</span>\n<span class=\"hljs-keyword\">import</span> Data.Aeson\n<span class=\"hljs-keyword\">import</span> Data.Map\n<span class=\"hljs-keyword\">import</span> Control.Applicative\n<span class=\"hljs-keyword\">import</span> Control.Monad (<span class=\"hljs-title\">mzero</span>)\n\n<span class=\"hljs-keyword\">import</span> Network.HTTP.Conduit <span class=\"hljs-comment\">-- the main module</span>\n\n<span class=\"hljs-comment\">-- The streaming interface uses conduits</span>\n<span class=\"hljs-keyword\">import</span> Data.Conduit\n<span class=\"hljs-keyword\">import</span> Data.Conduit.Binary (<span class=\"hljs-title\">sinkFile</span>)\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">qualified</span> Data.ByteString.Lazy.Char8 <span class=\"hljs-keyword\">as</span> L\n<span class=\"hljs-keyword\">import</span> Control.Monad.IO.Class (<span class=\"hljs-title\">liftIO</span>)\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">newtype</span> <span class=\"hljs-type\">Params</span> = <span class=\"hljs-type\">Params</span> (<span class=\"hljs-type\">Map</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-type\">String</span>) <span class=\"hljs-keyword\">deriving</span> (<span class=\"hljs-type\">Show</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">instance</span> <span class=\"hljs-type\">FromJSON</span> <span class=\"hljs-type\">Params</span> <span class=\"hljs-keyword\">where</span></span>\n  parseJSON val = <span class=\"hljs-type\">Params</span>  parseJSON val\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-type\">ResponseHeader</span> = <span class=\"hljs-type\">ResponseHeader</span> {\n  <span class=\"hljs-title\">status</span> :: <span class=\"hljs-type\">Int</span>,\n  <span class=\"hljs-title\">qTime</span>  :: <span class=\"hljs-type\">Int</span>,\n  <span class=\"hljs-title\">params</span> :: <span class=\"hljs-type\">Params</span>\n} <span class=\"hljs-keyword\">deriving</span> (<span class=\"hljs-type\">Show</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">instance</span> <span class=\"hljs-type\">FromJSON</span> <span class=\"hljs-type\">ResponseHeader</span> <span class=\"hljs-keyword\">where</span></span>\n  parseJSON (<span class=\"hljs-type\">Object</span> o) = <span class=\"hljs-type\">ResponseHeader</span>  o .: <span class=\"hljs-string\">\"status\"</span>\n                                         o .: <span class=\"hljs-string\">\"QTime\"</span>\n                                         o .: <span class=\"hljs-string\">\"params\"</span>\n  parseJSON _ = mzero\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-type\">Docs</span> = <span class=\"hljs-type\">Docs</span> {\n  <span class=\"hljs-title\">_yz_id</span> :: <span class=\"hljs-type\">String</span>,\n  <span class=\"hljs-title\">_yz_rk</span> :: <span class=\"hljs-type\">String</span>,\n  <span class=\"hljs-title\">_yz_rt</span> :: <span class=\"hljs-type\">String</span>,\n  <span class=\"hljs-title\">_yz_rb</span> :: <span class=\"hljs-type\">String</span>\n} <span class=\"hljs-keyword\">deriving</span> (<span class=\"hljs-type\">Show</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">instance</span> <span class=\"hljs-type\">FromJSON</span> <span class=\"hljs-type\">Docs</span> <span class=\"hljs-keyword\">where</span></span>\n  parseJSON (<span class=\"hljs-type\">Object</span> o) = <span class=\"hljs-type\">Docs</span>  o .: <span class=\"hljs-string\">\"_yz_id\"</span>\n                               o .: <span class=\"hljs-string\">\"_yz_rk\"</span>\n                               o .: <span class=\"hljs-string\">\"_yz_rt\"</span>\n                               o .: <span class=\"hljs-string\">\"_yz_rb\"</span>\n  parseJSON _ = mzero   \n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-type\">Results</span> = <span class=\"hljs-type\">Results</span> {\n  <span class=\"hljs-title\">numFound</span> :: <span class=\"hljs-type\">Int</span>,\n  <span class=\"hljs-title\">start</span> :: <span class=\"hljs-type\">Int</span>,\n  <span class=\"hljs-title\">maxScore</span> :: <span class=\"hljs-type\">Float</span>,\n  <span class=\"hljs-title\">docs</span> :: [<span class=\"hljs-type\">Docs</span>]\n} <span class=\"hljs-keyword\">deriving</span> (<span class=\"hljs-type\">Show</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">instance</span> <span class=\"hljs-type\">FromJSON</span> <span class=\"hljs-type\">Results</span> <span class=\"hljs-keyword\">where</span></span>\n  parseJSON (<span class=\"hljs-type\">Object</span> o) = <span class=\"hljs-type\">Results</span>  o .: <span class=\"hljs-string\">\"numFound\"</span>\n                                  o .: <span class=\"hljs-string\">\"start\"</span>\n                                  o .: <span class=\"hljs-string\">\"maxScore\"</span>\n                                  o .: <span class=\"hljs-string\">\"docs\"</span>\n  parseJSON _ = mzero\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-type\">SolrResponse</span> = <span class=\"hljs-type\">SolrResponse</span> {\n  <span class=\"hljs-title\">responseHeader</span> :: <span class=\"hljs-type\">ResponseHeader</span>,\n  <span class=\"hljs-title\">response</span> :: <span class=\"hljs-type\">Results</span>\n} <span class=\"hljs-keyword\">deriving</span> (<span class=\"hljs-type\">Show</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">instance</span> <span class=\"hljs-type\">FromJSON</span> <span class=\"hljs-type\">SolrResponse</span> <span class=\"hljs-keyword\">where</span></span>\n  parseJSON (<span class=\"hljs-type\">Object</span> o) = <span class=\"hljs-type\">SolrResponse</span>  o .: <span class=\"hljs-string\">\"responseHeader\"</span>\n                                       o .: <span class=\"hljs-string\">\"response\"</span>\n  parseJSON _ = mzero\n\n<span class=\"hljs-title\">main</span> :: <span class=\"hljs-type\">IO</span> ()\n<span class=\"hljs-title\">main</span> = <span class=\"hljs-keyword\">do</span>\n</code></pre>\n<p>and running <code>main</code> in ghci gives us:</p>\n<p><code>&lt;code class=&quot;haskell&quot;&gt;Just (SolrResponse {responseHeader = ResponseHeader {status = 0, qTime = 8, params = Params (fromList [(&quot;127.0.0.1:8093&quot;,&quot;_yz_pn:63 OR (_yz_pn:60 AND (_yz_fpn:60)) OR _yz_pn:59 OR _yz_pn:56 OR _yz_pn:53 OR _yz_pn:50 OR _yz_pn:47 OR _yz_pn:44 OR _yz_pn:41 OR _yz_pn:38 OR _yz_pn:35 OR _yz_pn:32 OR _yz_pn:29 OR _yz_pn:26 OR _yz_pn:23 OR _yz_pn:20 OR _yz_pn:17 OR _yz_pn:14 OR _yz_pn:11 OR _yz_pn:8 OR _yz_pn:5 OR _yz_pn:2&quot;),(&quot;q&quot;,&quot;*:*&quot;),(&quot;shards&quot;,&quot;127.0.0.1:8093/solr/my_index&quot;),(&quot;wt&quot;,&quot;json&quot;)])}, response = Results {numFound = 2, start = 0, maxScore = 1.0, docs = [Docs {_yz_id = &quot;data_my_bucket_name_11&quot;, _yz_rk = &quot;name&quot;, _yz_rt = &quot;data&quot;, _yz_rb = &quot;my_bucket&quot;},Docs {_yz_id = &quot;data_my_bucket_second_14&quot;, _yz_rk = &quot;second&quot;, _yz_rt = &quot;data&quot;, _yz_rb = &quot;my_bucket&quot;}]}})</code></p>\n<p>Success!</p>\n<p>This is just a small start. Hopefully I’ll be able to build this out a bit more (two changes of note will be usage of <code>http-streams</code> and <code>Lens</code>) and write a snaplet that integrates well with <a href=\"https://github.com/ChristopherBiscardi/snaplet-riak-2\">this Riak Snaplet</a> in a more generic fashion.</p>\n"}}}