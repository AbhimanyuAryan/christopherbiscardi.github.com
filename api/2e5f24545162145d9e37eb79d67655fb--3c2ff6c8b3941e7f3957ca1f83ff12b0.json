{"data":{"root":{"post":{"body":"<p>Recently when implementing a Docker Registry I came across the need to\nhash the incoming request body in a way that matches the clients\nhash. Since the Docker engine is an existing client that speaks a\ncouple of different <code>Content-Type</code>s (such as\n<code>application/vnd.docker.distribution.manifest.v2+json</code>, we cannot use\nServant’s alternate content types to get a ByteString to hash. This\nleads us to one possible implementation, which is to create a new\ncontent type that uses\n<code>application/vnd.docker.distribution.manifest.v2+json</code> as the <code>Accept</code>\nheader, but also hashes the content body with <code>SHA256</code>. Our content\ntype will behave very similarly to <code>application/json</code>.</p>\n<p>We will use <a href=\"https://hackage.haskell.org/package/cryptonite\">cryptonite</a> for hashing and <a href=\"https://hackage.haskell.org/package/aeson\">Aeson</a>\nfor JSON decoding. The full code follows.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"hljs-meta\">{-# LANGUAGE FlexibleInstances     #-}</span>\n<span class=\"hljs-meta\">{-# LANGUAGE MultiParamTypeClasses #-}</span>\n<span class=\"hljs-meta\">{-# LANGUAGE OverloadedStrings     #-}</span>\n<span class=\"highlight__hljs-keyword___som98\">module</span> SR.HashedJSONContentType <span class=\"highlight__hljs-keyword___som98\">where</span>\n\n<span class=\"highlight__hljs-keyword___som98\">import</span>           Crypto.Hash                (<span class=\"highlight__hljs-type___11WfV\">Digest</span>, <span class=\"highlight__hljs-type___11WfV\">SHA256</span>)\n<span class=\"highlight__hljs-keyword___som98\">import</span>           Data.Aeson\n<span class=\"highlight__hljs-keyword___som98\">import</span> <span class=\"highlight__hljs-keyword___som98\">qualified</span> Data.ByteString.Lazy.Char8 <span class=\"highlight__hljs-keyword___som98\">as</span> BSC\n<span class=\"highlight__hljs-keyword___som98\">import</span>           Network.HTTP.Media         <span class=\"highlight__hljs-keyword___som98\">hiding</span> (<span class=\"highlight__hljs-type___11WfV\">Accept</span>)\n<span class=\"highlight__hljs-keyword___som98\">import</span>           Servant.API.ContentTypes\n\n<span class=\"highlight__hljs-keyword___som98\">import</span>           Utils                      (<span class=\"highlight__hljs-title___1fl8Q\">mkDigest</span>)\n\n<span class=\"highlight__hljs-class___mOeOV\"><span class=\"highlight__hljs-keyword___som98\">data</span> <span class=\"highlight__hljs-type___11WfV\">HashedJSON</span> = <span class=\"highlight__hljs-type___11WfV\">HashedJSON</span> <span class=\"highlight__hljs-type___11WfV\">String</span></span>\n<span class=\"highlight__hljs-class___mOeOV\">\n<span class=\"highlight__hljs-keyword___som98\">instance</span> <span class=\"highlight__hljs-type___11WfV\">Accept</span> <span class=\"highlight__hljs-type___11WfV\">HashedJSON</span> <span class=\"highlight__hljs-keyword___som98\">where</span></span>\n  contentType _ = <span class=\"highlight__hljs-string___1SffY\">\"application\"</span> // <span class=\"highlight__hljs-string___1SffY\">\"vnd.docker.distribution.manifest.v2+json\"</span>\n\n<span class=\"highlight__hljs-comment___UYk12\">-- | We don't need MimeRender for this since we are only using </span>\n<span class=\"highlight__hljs-comment___UYk12\">--   the content-type for receiving data.</span>\n<span class=\"highlight__hljs-comment___UYk12\">-- instance Show a =&gt; MimeRender HashedJSON a where</span>\n<span class=\"highlight__hljs-comment___UYk12\">--    mimeRender _ val = pack (\"This is MINE! \" ++ show val)</span>\n<span class=\"highlight__hljs-class___mOeOV\">\n<span class=\"highlight__hljs-keyword___som98\">instance</span> <span class=\"highlight__hljs-type___11WfV\">FromJSON</span> a =&gt; <span class=\"highlight__hljs-type___11WfV\">MimeUnrender</span> <span class=\"highlight__hljs-type___11WfV\">HashedJSON</span> (<span class=\"highlight__hljs-type___11WfV\">Digest</span> <span class=\"highlight__hljs-type___11WfV\">SHA256</span>, <span class=\"highlight__hljs-title___1fl8Q\">a</span>) <span class=\"highlight__hljs-keyword___som98\">where</span></span>\n   mimeUnrender _ bs = <span class=\"highlight__hljs-keyword___som98\">case</span> eitherDecodeLenient bs <span class=\"highlight__hljs-keyword___som98\">of</span>\n     <span class=\"highlight__hljs-type___11WfV\">Left</span> err -&gt; <span class=\"highlight__hljs-type___11WfV\">Left</span> err\n     <span class=\"highlight__hljs-type___11WfV\">Right</span> val -&gt; <span class=\"highlight__hljs-type___11WfV\">Right</span> (mkDigest $ <span class=\"highlight__hljs-type___11WfV\">BSC</span>.toStrict bs, val)\n</code></pre>\n<p>The most interesting part is the <code>MimeUnrender</code> instance for our\ncustom content type <code>HashedJSON</code>. Servant provides a more lenient\nversion of Aeson’s <code>decode</code> called <code>eitherDecodeLenient</code>. We use this\nfor compatibility with the normal <code>'JSON</code> content type in Servant.</p>\n<p>The instance uses a tuple <code>(Digest SHA256, a)</code> so any route types we\nwrite in the future will look similar to the following code which uses\na fake type <code>OurType</code>.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"highlight__hljs-type___11WfV\">ReqBody</span> '[<span class=\"highlight__hljs-type___11WfV\">HashedJSON</span>] (<span class=\"highlight__hljs-type___11WfV\">Digest</span> <span class=\"highlight__hljs-type___11WfV\">SHA256</span>, <span class=\"highlight__hljs-type___11WfV\">OurType</span>) \n</code></pre>\n<p>An example handler using the above <code>ReqBody</code> declaration follows.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"highlight__hljs-title___1fl8Q\">putManifest</span> :: (<span class=\"highlight__hljs-type___11WfV\">CH</span>.<span class=\"highlight__hljs-type___11WfV\">Digest</span> <span class=\"highlight__hljs-type___11WfV\">CH</span>.<span class=\"highlight__hljs-type___11WfV\">SHA256</span>, <span class=\"highlight__hljs-type___11WfV\">Manifest</span>) -&gt; <span class=\"highlight__hljs-type___11WfV\">App</span> <span class=\"highlight__hljs-type___11WfV\">NoContent</span>)\n<span class=\"highlight__hljs-title___1fl8Q\">putManifest</span> (digest, manifest) = <span class=\"highlight__hljs-keyword___som98\">do</span>\n  <span class=\"highlight__hljs-comment___UYk12\">-- do stuff with digests and manifests</span>\n  return <span class=\"highlight__hljs-type___11WfV\">NoContent</span>\n</code></pre>\n<p>One can envision how changing the type of the hash in the type might\nallow us to specify which algorithm we want to use in the same way\nthat we specify <code>Manifest</code>.</p>\n","attributes":{"title":"Servant Custom Content Types","updatedAt":"Oct 3rd, 2016","publishedAt":"Oct 3rd, 2016","timeToRead":2,"headerImage":"/4697ea4ccbcd2ba2f293936baed59b9d.png","url":"/servant-custom-content-types/","canonicalURL":null,"excerpt":"Recently when implementing a Docker Registry I came across the need to\nhash the incoming request body in a way that matches the…","__typename":"BlogPostAttributes"},"__typename":"BlogPost"},"__typename":"Query"}}}