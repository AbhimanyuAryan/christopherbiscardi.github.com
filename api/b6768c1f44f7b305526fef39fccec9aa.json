{"data":{"post":{"body":"<p>I wrote a simple Haxl DataSource and I thought it would be good to share. If you don’t know what Haxl is you can find out more <a href=\"https://github.com/facebook/Haxl\">here</a>.</p>\n<p>The gist with the relevant .cabal and DataSource is <a href=\"https://gist.github.com/ChristopherBiscardi/45c765eb292d96ab4549\">here</a></p>\n<h2>Table</h2>\n<p>We will need a people table to store our people:</p>\n<pre><code>&lt;<span class=\"hljs-built_in\">code</span> class=<span class=\"hljs-string\">\"sql\"</span> style=<span class=\"hljs-string\">\"overflow-x:auto\"</span>&gt;<span class=\"hljs-keyword\">CREATE</span> TABLE people (\n    _id bigserial primary <span class=\"hljs-built_in\">key</span>,\n    first_name text <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-built_in\">NULL</span>,\n    last_name text <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-built_in\">NULL</span>,\n    age int <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-built_in\">NULL</span>\n);```\n\n<span class=\"hljs-keyword\">And</span> some data to query:\n\n</code></pre>\n<p><code class=\"sql\" style=\"overflow-x:auto\">INSERT INTO people (“first_name”, “last_name”, “age”) VALUES (‘Bob’,‘Seger’,69);\nINSERT INTO people (“first_name”, “last_name”, “age”) VALUES (‘Billy’,‘Idol’,58);```</p>\n<p>which gives us a table that looks like:</p>\n<pre><code><span class=\"hljs-variable\">&lt;code class=\"asciidoc\" style=\"overflow-x:auto\"&gt;</span>peopledb=<span class=\"hljs-comment\"># select * from people;</span>\n _id |<span class=\"hljs-string\"> first_name </span>|<span class=\"hljs-string\"> last_name </span>|<span class=\"hljs-string\"> age\n-----+------------+-----------+-----\n   1 </span>|<span class=\"hljs-string\"> Bob        </span>|<span class=\"hljs-string\"> Seger     </span>|<span class=\"hljs-string\">  69\n   2 </span>|<span class=\"hljs-string\"> Billy      </span>|<span class=\"hljs-string\"> Idol      </span>|<span class=\"hljs-string\">  58\n(2 rows)```\n\nWe can then head into ghci and check out the Haxl DataSource.\n\n</span></code></pre>\n<p><code class=\"ghci\" style=\"overflow-x:auto\">ghci DataSource.hs\nlet cinfo = defaultConnectInfo {connectUser = “pgsuper”, connectPassword = “password”, connectDatabase = “peopledb”}\npgstate ```</p>\n<p>If we check out the value of <code>r</code> we see a <code>Just Person</code>.</p>\n<p><code>&lt;code class=&quot;ghci&quot; style=&quot;overflow-x:auto&quot;&gt;Just (Person {_id = PersonId 1, first_name = &quot;Bob&quot;, last_name = &quot;Seger&quot;, age = 69})</code></p>\n<h2>The Code</h2>\n<p>First, we need a datatype to be querying. Of note is that we’ve <code>newtype</code>'d <code>PersonId</code>, so we’ll use <code>GeneralizedNewtypeDeriving</code> to get the <code>FromField</code> instance from <code>Int</code></p>\n<pre><code>&lt;code <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"haskell\"</span> style=<span class=\"hljs-string\">\"overflow-x:auto\"</span>&gt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">newtype</span> <span class=\"hljs-type\">PersonId</span> = <span class=\"hljs-type\">PersonId</span> <span class=\"hljs-type\">Int</span> <span class=\"hljs-keyword\">deriving</span> (<span class=\"hljs-type\">Show</span>, <span class=\"hljs-type\">Eq</span>, <span class=\"hljs-type\">FromField</span>)</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-type\">Person</span> = <span class=\"hljs-type\">Person</span> { <span class=\"hljs-title\">_id</span>        :: <span class=\"hljs-type\">PersonId</span>\n                     , <span class=\"hljs-title\">first_name</span> :: <span class=\"hljs-type\">Text</span>\n                     , <span class=\"hljs-title\">last_name</span>  :: <span class=\"hljs-type\">Text</span>\n                     , <span class=\"hljs-title\">age</span>        :: <span class=\"hljs-type\">Int</span> } <span class=\"hljs-keyword\">deriving</span> (<span class=\"hljs-type\">Show</span>, <span class=\"hljs-type\">Typeable</span>)```</span>\n\n<span class=\"hljs-type\">Next</span> we'll define our requests <span class=\"hljs-keyword\">as</span> a <span class=\"hljs-type\">GADT</span>. <span class=\"hljs-type\">In</span> this <span class=\"hljs-keyword\">case</span> we only have a single request <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span>: \"<span class=\"hljs-type\">GetPerson</span>\", which takes a `<span class=\"hljs-type\">PersonId</span>` and looks up that user.</span>\n\n</code></pre>\n<p><code class=\"haskell\" style=\"overflow-x:auto\">data PGReq a where\nGetPerson :: PersonId -&gt; PGReq (Maybe Person)\nderiving Typeable```</p>\n<p>Now we need some simple boilerplate. The Hashable instance defines the hash of our request types for the cache. In this case a <code>GetPerson</code> request is as a tuple of <code>(0,PersonId)</code>.</p>\n<pre><code>&lt;code class=<span class=\"hljs-string\">\"haskell\"</span> style=<span class=\"hljs-string\">\"overflow-x:auto\"</span>&gt;deriving<span class=\"hljs-built_in\"> instance </span>Eq (PGReq a)\nderiving<span class=\"hljs-built_in\"> instance </span>Show (PGReq a)\n<span class=\"hljs-built_in\">\ninstance </span>Show1 PGReq where show1 = show\n<span class=\"hljs-built_in\">\ninstance </span>Hashable (PGReq a) where\n  hashWithSalt s (GetPerson (PersonId pid)) = hashWithSalt s (0::Int, pid)```\n\nFollowing the boilerplate we'll create a `StateKey` instance. Since this is a simple implementation, we'll put the connection information in our state so we can create connections later. We'll also define a function to initialize said state.\n\n</code></pre>\n<p><code class=\"haskell\" style=\"overflow-x:auto\">instance StateKey PGReq where\ndata State PGReq =\nPGState\n{ connInfo :: ConnectInfo }</p>\n<p>initHaxlState\n:: ConnectInfo\n-&gt; IO (State PGReq)\ninitHaxlState cInfo = do\nreturn PGState\n{ connInfo = cInfo }```</p>\n<p>Haxl needs us to name our DataSource and tell it which function to use for fetching data.</p>\n<pre><code>&lt;code <span class=\"hljs-built_in\">class</span>=<span class=\"hljs-string\">\"haskell\"</span> style=<span class=\"hljs-string\">\"overflow-x:auto\"</span>&gt;instance DataSourceName PGReq <span class=\"hljs-keyword\">where</span>\n  dataSourceName _ = <span class=\"hljs-string\">\"Postgres\"</span>\n\ninstance DataSource u PGReq <span class=\"hljs-keyword\">where</span>\n  fetch = pgFetch```\n\nThen we can define our asynchronous fetch functions which will process our `BlockedFetch`es. We <span class=\"hljs-keyword\">put</span> a failure <span class=\"hljs-keyword\">on</span> exceptions <span class=\"hljs-keyword\">and</span> pass <span class=\"hljs-keyword\">the</span> data <span class=\"hljs-keyword\">through</span> <span class=\"hljs-keyword\">on</span> a success.\n\n</code></pre>\n<p><code class=\"haskell\" style=\"overflow-x:auto\">pgFetch\n:: State PGReq\n-&gt; Flags\n-&gt; u\n-&gt; [BlockedFetch PGReq]\n-&gt; PerformFetch\npgFetch PGState {…} _flags _user bfs =\nAsyncFetch $ \\inner -&gt; do\nasyncs  BlockedFetch PGReq\n-&gt; IO (Async ())\nfetchAsync creds (BlockedFetch req rvar) =\nasync $ do\nbracket (connect creds) (close) $ \\conn -&gt; do\ne  putFailure rvar (ex :: SomeException)\nRight val -&gt; putSuccess rvar val```</p>\n<p>Finally, we can define our application logic. In this case our only request type is <code>GetPerson</code>, so we need to get a single <code>Person</code> by <code>PersonId</code>. We could also write more <code>fetchReq</code> patterns if we had more request types.</p>\n<p><code>getPerson</code> is the function we’ll actually call to get a person by id; As seen in the intro to this post.</p>\n<pre><code>&lt;<span class=\"hljs-selector-tag\">code</span> class=<span class=\"hljs-string\">\"haskell\"</span> style=<span class=\"hljs-string\">\"overflow-x:auto\"</span>&gt;fetchReq\n  :: Connection\n  -&gt; PGReq <span class=\"hljs-selector-tag\">a</span>\n  -&gt; IO <span class=\"hljs-selector-tag\">a</span>\nfetchReq conn (GetPerson (PersonId pid)) = do\n  people  GenHaxl u (Maybe Person)\ngetPerson pid = dataFetch (GetPerson pid)```\n\n\n</code></pre>\n"}}}