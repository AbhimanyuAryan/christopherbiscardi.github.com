<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title data-react-helmet="true">Quick Tip: Haskell List Comprehensions</title><meta data-react-helmet="true" property="description" content="I think list
comprehensions
are my favorite reason to pull out Haskell."/><meta data-react-helmet="true" property="og:title" content="Quick Tip: Haskell List Comprehensions"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:url" content="http://christopherbiscardi.com/2013/2/8/quick-tip-haskell-list-comprehensions/"/><meta data-react-helmet="true" property="og:description" content="I think list
comprehensions
are my favorite reason to pull out Haskell."/><meta data-react-helmet="true" property="og:image" content="http://christopherbiscardi.comnull"/><meta data-react-helmet="true" property="twitter:card" content="summary"/><meta data-react-helmet="true" property="twitter:title" content="Quick Tip: Haskell List Comprehensions"/><meta data-react-helmet="true" property="twitter:description" content="I think list
comprehensions
are my favorite reason to pull out Haskell."/><meta data-react-helmet="true" property="twitter:url" content="http://christopherbiscardi.com/2013/2/8/quick-tip-haskell-list-comprehensions/"/><link rel="stylesheet" type="text/css" href="/styles.f25bf9e6682280946ba2e441a544b407.css"/></head><body class="landing-page"><div id="content"><div data-reactroot="" data-reactid="1" data-react-checksum="-595108231"><div class="Nav__wrapper___u7BUA" data-reactid="2"><nav class="Nav__nav___1e2Pp" data-reactid="3"><a class="Nav__logoWrapper___35yvY" href="/" data-reactid="4"><img class="Nav__logo___sw4O9" src="/69305db2985e926d498b513a21d28383.png" data-reactid="5"/></a><ul class="Nav__items___1oDCD" data-reactid="6"><li data-reactid="7"><a class="Nav__itemLink___H6Isv" href="/posts/" data-reactid="8">Posts</a></li><li data-reactid="9"><a href="https://github.com/ChristopherBiscardi/ama/issues?q=is%3Aissue+is%3Aclosed" class="Nav__itemLink___H6Isv" data-reactid="10">AMA</a></li><li data-reactid="11"><a class="Nav__itemLink___H6Isv" href="/books/" data-reactid="12">Books</a></li><li data-reactid="13"><a class="Nav__itemLink___H6Isv" href="/projects/" data-reactid="14">Projects</a></li><li data-reactid="15"><a class="Nav__itemLink___H6Isv" href="/about/" data-reactid="16">About</a></li></ul></nav></div><div data-reactid="17"><div class="Post__page___15ves" data-reactid="18"><!-- react-empty: 19 --><div class="Post__container___f_rKX" data-reactid="20"><div class="Post__singleColumn___tYK8R" data-reactid="21"><h1 class="Post__title___2I6DZ" data-reactid="22">Quick Tip: Haskell List Comprehensions</h1><div class="Post__meta___1fVoc" data-reactid="23"><!-- react-text: 24 -->Feb 8th, 2013<!-- /react-text --><!-- react-text: 25 --> · <!-- /react-text --><!-- react-text: 26 -->1<!-- /react-text --><!-- react-text: 27 --> minute read<!-- /react-text --></div></div></div><div class="Post__container___f_rKX" data-reactid="28"><div class="Post__singleColumn___tYK8R" data-reactid="29"><div data-reactid="30"><p>I think <a href="http://learnyouahaskell.com/starting-out#im-a-list-comprehension">list
comprehensions</a>
are my favorite reason to pull out Haskell.</p>
<p>For example: I was recently asked this:</p>
<p>You have a row of 100 school lockers. For each number from 1 to 100 walk down
the line of lockers starting at the beginning, and switch the state of every nth
locker. All of the lockers start closed.</p>
<p>For example:
we start off at 1 and switch all the lockers to open. (1,2,3,4,5,…)
we then go to 2 and switch all of the lockers evenly divisible by 2. (2,4,6,8…)
for 3 we flip every 3rd locker (3,6,9,12,…)
4 is every 4th locker. (4,8,12,16,…)
etc.</p>
<h4 id="answer-below-this-line">Answer Below This Line</h4>
<p>In Haskell this is easily accomplished using a list comprehension.</p>
<p>We can observe through trial (ie: actually flipping every locker) that the
lockers are flipped by their factors. (ie: 6 is flipped by 1,2,3,and 6), so
we’ll write a quick comprehension to give us the factors of a number:</p>
<p>In this example, we get the factors of 6</p>
<pre class="highlight__hljs___FzKxy index__p2___65FBl"><code>[x | x
</code></pre>
<p>links:
<a href="http://learnyouahaskell.com/starting-out#texas-ranges">[1…6]</a>
<a href="http://en.wikipedia.org/wiki/Modulo_operation">modulo</a>
<a href="http://zvon.org/other/haskell/Outputprelude/mod_f.html">mod</a>
<a href="http://www.haskell.org/haskellwiki/Infix_operator"><code>infix</code></a></p>
<p>Essentially you can read the above code as</p>
<pre class="highlight__hljs___FzKxy index__p2___65FBl"><code><span class="highlight__hljs-type___11WfV">Give</span> me x <span class="highlight__hljs-keyword___som98">where</span> x is [<span class="highlight__hljs-number___2gmaH">1</span>,<span class="highlight__hljs-number___2gmaH">2</span>,<span class="highlight__hljs-number___2gmaH">3</span>,<span class="highlight__hljs-number___2gmaH">4</span>,<span class="highlight__hljs-number___2gmaH">5</span>,<span class="highlight__hljs-number___2gmaH">6</span>] and <span class="highlight__hljs-number___2gmaH">6</span> is evenly divisible by x
</code></pre>
<p>and breaking it down:</p>
<pre class="highlight__hljs___FzKxy index__p2___65FBl"><code><span class="highlight__hljs-type___11WfV">Give</span> me x
[x

<span class="highlight__hljs-title___1fl8Q">where</span>
|

<span class="highlight__hljs-title___1fl8Q">x</span>

<span class="highlight__hljs-title___1fl8Q">is</span>
</code></pre>
<p>We can then realize that if you flip something an even number of times, nothing
changes. This means we’re looking for the number with an odd number of factors
because we want the lockers that are open at the end.</p>
<p>The code to determine an open locker will look like this, where factors is the
code we just wrote.</p>
<pre class="highlight__hljs___FzKxy index__p2___65FBl"><code><span class="highlight__hljs-title___1fl8Q">length</span> factors `mod` <span class="highlight__hljs-number___2gmaH">2</span> == <span class="highlight__hljs-number___2gmaH">1</span>
</code></pre>
<p>If we stick that in a list comprehension for all numbers [1…100] we have
effectively filtered out all of the open lockers.</p>
<pre class="highlight__hljs___FzKxy index__p2___65FBl"><code>[n | n
</code></pre>
<p>But wait! There’s more! For the low low price of $19.95 we can realize there’s a
pattern in the results. The pattern happens to be perfect squares. This is
because perfect squares are the only numbers with an odd number of factors!</p>
<p>for example:
9’s factors are 1,3 and 9.
While 8’s factors are 1,2,4 and 8</p>
<p>We can now write a far more efficient list comprehension.</p>
<pre class="highlight__hljs___FzKxy index__p2___65FBl"><code>[x*x | x &lt;- [<span class="highlight__hljs-number___2gmaH">1.</span><span class="highlight__hljs-number___2gmaH">.10</span>]]
</code></pre>
<p>Which can be read as:
give me x*x where x is [1,2,3,4,5,6,7,8,9,10]</p>
<p>We can also expand this into an function using an infinite list, just in case we
want to calculate how many lockers are open if we have 50081 lockers.</p>
<pre class="highlight__hljs___FzKxy index__p2___65FBl"><code><span class="highlight__hljs-title___1fl8Q">let</span> lockers = [x*x | x
</code></pre>
</div></div></div></div></div></div></div><script charset="UTF-8">window.__APOLLO_STATE__={"apollo":{"data":{"$ROOT_QUERY.root.post({\"slug\":\"quick-tip-haskell-list-comprehensions\"})":{"body":"<p>I think <a href=\"http://learnyouahaskell.com/starting-out#im-a-list-comprehension\">list\ncomprehensions</a>\nare my favorite reason to pull out Haskell.</p>\n<p>For example: I was recently asked this:</p>\n<p>You have a row of 100 school lockers. For each number from 1 to 100 walk down\nthe line of lockers starting at the beginning, and switch the state of every nth\nlocker. All of the lockers start closed.</p>\n<p>For example:\nwe start off at 1 and switch all the lockers to open. (1,2,3,4,5,…)\nwe then go to 2 and switch all of the lockers evenly divisible by 2. (2,4,6,8…)\nfor 3 we flip every 3rd locker (3,6,9,12,…)\n4 is every 4th locker. (4,8,12,16,…)\netc.</p>\n<h4 id=\"answer-below-this-line\">Answer Below This Line</h4>\n<p>In Haskell this is easily accomplished using a list comprehension.</p>\n<p>We can observe through trial (ie: actually flipping every locker) that the\nlockers are flipped by their factors. (ie: 6 is flipped by 1,2,3,and 6), so\nwe’ll write a quick comprehension to give us the factors of a number:</p>\n<p>In this example, we get the factors of 6</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code>[x | x\n</code></pre>\n<p>links:\n<a href=\"http://learnyouahaskell.com/starting-out#texas-ranges\">[1…6]</a>\n<a href=\"http://en.wikipedia.org/wiki/Modulo_operation\">modulo</a>\n<a href=\"http://zvon.org/other/haskell/Outputprelude/mod_f.html\">mod</a>\n<a href=\"http://www.haskell.org/haskellwiki/Infix_operator\"><code>infix</code></a></p>\n<p>Essentially you can read the above code as</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"highlight__hljs-type___11WfV\">Give</span> me x <span class=\"highlight__hljs-keyword___som98\">where</span> x is [<span class=\"highlight__hljs-number___2gmaH\">1</span>,<span class=\"highlight__hljs-number___2gmaH\">2</span>,<span class=\"highlight__hljs-number___2gmaH\">3</span>,<span class=\"highlight__hljs-number___2gmaH\">4</span>,<span class=\"highlight__hljs-number___2gmaH\">5</span>,<span class=\"highlight__hljs-number___2gmaH\">6</span>] and <span class=\"highlight__hljs-number___2gmaH\">6</span> is evenly divisible by x\n</code></pre>\n<p>and breaking it down:</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"highlight__hljs-type___11WfV\">Give</span> me x\n[x\n\n<span class=\"highlight__hljs-title___1fl8Q\">where</span>\n|\n\n<span class=\"highlight__hljs-title___1fl8Q\">x</span>\n\n<span class=\"highlight__hljs-title___1fl8Q\">is</span>\n</code></pre>\n<p>We can then realize that if you flip something an even number of times, nothing\nchanges. This means we’re looking for the number with an odd number of factors\nbecause we want the lockers that are open at the end.</p>\n<p>The code to determine an open locker will look like this, where factors is the\ncode we just wrote.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"highlight__hljs-title___1fl8Q\">length</span> factors `mod` <span class=\"highlight__hljs-number___2gmaH\">2</span> == <span class=\"highlight__hljs-number___2gmaH\">1</span>\n</code></pre>\n<p>If we stick that in a list comprehension for all numbers [1…100] we have\neffectively filtered out all of the open lockers.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code>[n | n\n</code></pre>\n<p>But wait! There’s more! For the low low price of $19.95 we can realize there’s a\npattern in the results. The pattern happens to be perfect squares. This is\nbecause perfect squares are the only numbers with an odd number of factors!</p>\n<p>for example:\n9’s factors are 1,3 and 9.\nWhile 8’s factors are 1,2,4 and 8</p>\n<p>We can now write a far more efficient list comprehension.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code>[x*x | x &lt;- [<span class=\"highlight__hljs-number___2gmaH\">1.</span><span class=\"highlight__hljs-number___2gmaH\">.10</span>]]\n</code></pre>\n<p>Which can be read as:\ngive me x*x where x is [1,2,3,4,5,6,7,8,9,10]</p>\n<p>We can also expand this into an function using an infinite list, just in case we\nwant to calculate how many lockers are open if we have 50081 lockers.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"highlight__hljs-title___1fl8Q\">let</span> lockers = [x*x | x\n</code></pre>\n","attributes":{"type":"id","id":"$ROOT_QUERY.root.post({\"slug\":\"quick-tip-haskell-list-comprehensions\"}).attributes","generated":true},"__typename":"BlogPost"},"$ROOT_QUERY.root.post({\"slug\":\"quick-tip-haskell-list-comprehensions\"}).attributes":{"title":"Quick Tip: Haskell List Comprehensions","updatedAt":"Feb 8th, 2013","publishedAt":"Feb 8th, 2013","timeToRead":1,"headerImage":null,"url":"/2013/2/8/quick-tip-haskell-list-comprehensions/","canonicalURL":null,"excerpt":"I think list\ncomprehensions\nare my favorite reason to pull out Haskell.","__typename":"BlogPostAttributes"},"$ROOT_QUERY.root":{"post({\"slug\":\"quick-tip-haskell-list-comprehensions\"})":{"type":"id","id":"$ROOT_QUERY.root.post({\"slug\":\"quick-tip-haskell-list-comprehensions\"})","generated":true},"__typename":"Query"},"ROOT_QUERY":{"root":{"type":"id","id":"$ROOT_QUERY.root","generated":true}}}}};</script><script src="/js/client.js" charset="UTF-8"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-46878058-1', 'auto');
          ga('send', 'pageview');</script></body></html>