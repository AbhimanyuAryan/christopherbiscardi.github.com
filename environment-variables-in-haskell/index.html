<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" type="text/css" href="/styles.df72ee54210722a4ff300245e06a1b05.css"/></head><body class="landing-page"><div id="react-mount"><div data-reactid=".zpcy9oz4zk" data-react-checksum="49549658"><div class="Nav__wrapper___u7BUA" data-reactid=".zpcy9oz4zk.0"><nav class="Nav__nav___1e2Pp" data-reactid=".zpcy9oz4zk.0.0"><div class="Nav__logoWrapper___35yvY" data-reactid=".zpcy9oz4zk.0.0.0"><img class="Nav__logo___sw4O9" src="0576ff3991e0305da5b886052adbc044.png" data-reactid=".zpcy9oz4zk.0.0.0.0"/></div><ul class="Nav__items___1oDCD" data-reactid=".zpcy9oz4zk.0.0.1"><li data-reactid=".zpcy9oz4zk.0.0.1.0"><a class="Nav__itemLink___H6Isv" href="/posts" data-reactid=".zpcy9oz4zk.0.0.1.0.0">Posts</a></li><li data-reactid=".zpcy9oz4zk.0.0.1.1"><a class="Nav__itemLink___H6Isv" href="/talks" data-reactid=".zpcy9oz4zk.0.0.1.1.0">Talks</a></li><li data-reactid=".zpcy9oz4zk.0.0.1.2"><a class="Nav__itemLink___H6Isv" href="/books" data-reactid=".zpcy9oz4zk.0.0.1.2.0">Books</a></li><li data-reactid=".zpcy9oz4zk.0.0.1.3"><a class="Nav__itemLink___H6Isv" href="/projects" data-reactid=".zpcy9oz4zk.0.0.1.3.0">Projects</a></li></ul></nav></div><div data-reactid=".zpcy9oz4zk.1"><div data-reactid=".zpcy9oz4zk.1.0"><p>In this post we will go over how to accept environmental variables in Haskell.</p>
<p><a href="http://www.christopherbiscardi.com/post-conventions/">Conventions</a> used in this post.</p>
<pre><code>&lt;code <span class="hljs-keyword">class</span>=<span class="hljs-string">"haskell"</span>&gt;<span class="hljs-keyword">import</span> System.Environment

<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
</code></pre>
<p>We can compile this if we put it in a file called <code>env.hs</code>.</p>
<p><code>&lt;code class=&quot;bash&quot;&gt;ghc env.hs</code></p>
<p>and run it with an ad-hoc ENV variable:</p>
<p><code>&lt;code class=&quot;bash&quot;&gt;myvariable=&quot;what&quot; ./env</code></p>
<p>Which will print out:</p>
<p><code>&quot;what&quot;</code></p>
<p>but this will throw an error if the ENV var doesn’t exist:</p>
<pre><code>&lt;code class=<span class="hljs-string">"bash"</span>&gt;λ ./env
<span class="hljs-symbol">env: myvariable: getEnv:</span> does <span class="hljs-literal">not</span> exist (no environment variable)```

To solve that issue we can use `lookupEnv` with `fromMaybe`

</code></pre>
<p><code class="haskell">import System.Environment (lookupEnv)
import Data.Maybe (fromMaybe)</p>
<p>main :: IO ()
main = do</p>
<pre><code>
which will give us a <span class="hljs-keyword">default</span> value <span class="hljs-keyword">when</span> the ENV <span class="hljs-keyword">variable</span> doesn<span class="hljs-symbol">'t</span> exist:

</code></pre>
<p><code class="bash">λ ./env
&quot;mydefaultvalue&quot;
λ myvariable=“what” ./env
&quot;what&quot;```</p>
</div></div></div></div><script src="/js/bundle-72c0db642ea1de5f23b8.js"></script></body></html>