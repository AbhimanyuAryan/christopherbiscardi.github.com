<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" type="text/css" href="/styles.fb354817e9ba604f47bb6a23702bb15a.css"/></head><body class="landing-page"><div id="react-mount"><div data-reactid=".ak5cuvgksu" data-react-checksum="247303096"><div class="Nav__wrapper___u7BUA" data-reactid=".ak5cuvgksu.0"><nav class="Nav__nav___1e2Pp" data-reactid=".ak5cuvgksu.0.0"><a class="Nav__logoWrapper___35yvY" href="/" data-reactid=".ak5cuvgksu.0.0.0"><img class="Nav__logo___sw4O9" src="/69305db2985e926d498b513a21d28383.png" data-reactid=".ak5cuvgksu.0.0.0.0"/></a><ul class="Nav__items___1oDCD" data-reactid=".ak5cuvgksu.0.0.1"><li data-reactid=".ak5cuvgksu.0.0.1.0"><a class="Nav__itemLink___H6Isv" href="/posts" data-reactid=".ak5cuvgksu.0.0.1.0.0">Posts</a></li><li data-reactid=".ak5cuvgksu.0.0.1.1"><a href="https://github.com/ChristopherBiscardi/ama/issues?q=is%3Aissue+is%3Aclosed" class="Nav__itemLink___H6Isv" data-reactid=".ak5cuvgksu.0.0.1.1.0">AMA</a></li><li data-reactid=".ak5cuvgksu.0.0.1.2"><a class="Nav__itemLink___H6Isv" href="/books" data-reactid=".ak5cuvgksu.0.0.1.2.0">Books</a></li><li data-reactid=".ak5cuvgksu.0.0.1.3"><a class="Nav__itemLink___H6Isv" href="/projects" data-reactid=".ak5cuvgksu.0.0.1.3.0">Projects</a></li></ul></nav></div><div data-reactid=".ak5cuvgksu.1"><div class="Post__container___3xG6t" data-reactid=".ak5cuvgksu.1.0"><div class="Post__singleColumn___3RGaV" data-reactid=".ak5cuvgksu.1.0.0"><h1 class="Post__title___1k3xj" data-reactid=".ak5cuvgksu.1.0.0.0">Riak, HAProxy and Haskell: MultiMachine Vagrant on OSX</h1><div class="Post__meta___1jyEB" data-reactid=".ak5cuvgksu.1.0.0.1"><span data-reactid=".ak5cuvgksu.1.0.0.1.0">Feb 12th, 2014</span><span data-reactid=".ak5cuvgksu.1.0.0.1.1"> · </span><span data-reactid=".ak5cuvgksu.1.0.0.1.2">5</span><span data-reactid=".ak5cuvgksu.1.0.0.1.3"> minute read</span></div><div data-reactid=".ak5cuvgksu.1.0.0.2"><p><a href="http://res.cloudinary.com/diqzbm8lz/image/upload/v1428611515/vagrantriak_qhwv7l.gif"><img src="http://res.cloudinary.com/diqzbm8lz/image/upload/v1428611515/vagrantriak_qhwv7l.gif" alt="vagrantriak"></a></p>
<p>In this post we will go over how to set up five Riak nodes, cluster them, setup HAProxy on a sixth machine and run a Haskell environment in a seventh machine. This will allow us to query from our Haskell vm to our HAProxy vm and distribute the queries among a Riak cluster.</p>
<p>If you haven’t installed Vagrant, do that now:
<a href="http://www.vagrantup.com/">Vagrant</a></p>
<p>I used VirtualBox as a backing for Vagrant.
<a href="https://www.virtualbox.org/">VirtualBox</a></p>
<h1 id="tldr-running-the-code">tldr: Running the Code</h1>
<h2 id="the-base-box">The Base Box</h2>
<p>We will need Ubuntu 13.10 (Saucy Salamander), as this is the base box in our <code>Vagrantfile</code>s.</p>
<p><code>vagrant box add saucy-amd http://cloud-images.ubuntu.com/vagrant/saucy/current/saucy-server-cloudimg-amd64-vagrant-disk1.box</code></p>
<h2 id="cloning-the-repo">Cloning the Repo</h2>
<p>The code is contained in a git repo <a href="">here</a></p>
<p><code>git clone git@github.com:ChristopherBiscardi/Riak-HAProxy-Haskell-Vagrant.git</code></p>
<h2 id="getting-them-up">Getting Them Up</h2>
<p>The simplest way to get everything up and running is:</p>
<pre class="hljs"><code>&lt;code class=&quot;bash&quot;&gt;cd riak-haproxy-haskell-vagrant
vagrant up```

I personally like to bring up my databases first, then proxy, then webserver.

</code></pre>
<p><code class="bash">cd riak-haproxy-haskell-vagrant
vagrant up /riak[0-9]/
vagrant up haproxy
vagrant up web```</p>
<p>A gif of running <code>vagrant up haproxy</code> is availible <a href="http://www.christopherbiscardi.com/wp-content/uploads/2014/02/vagrantuphaproxy.gif">here</a></p>
<h2 id="testing">Testing</h2>
<p>We can be assured that everything has worked by running:</p>
<pre class="hljs"><code>&lt;code class=&quot;bash&quot;&gt;vagrant ssh web
curl 192.168.50.3:8098```

Which is curling the IP of our load balancer. This should return something like this from a Riak node:

</code></pre>
<code class="html" style="overflow-x:auto">
<pre><code>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/types&quot;&gt;riak_kv_wm_bucket_type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/buckets&quot;&gt;riak_kv_wm_buckets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/riak&quot;&gt;riak_kv_wm_buckets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/types&quot;&gt;riak_kv_wm_buckets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/buckets&quot;&gt;riak_kv_wm_counter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/types&quot;&gt;riak_kv_wm_crdt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/buckets&quot;&gt;riak_kv_wm_index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/types&quot;&gt;riak_kv_wm_index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/buckets&quot;&gt;riak_kv_wm_keylist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/types&quot;&gt;riak_kv_wm_keylist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/buckets&quot;&gt;riak_kv_wm_link_walker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/riak&quot;&gt;riak_kv_wm_link_walker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/types&quot;&gt;riak_kv_wm_link_walker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mapred&quot;&gt;riak_kv_wm_mapred&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/buckets&quot;&gt;riak_kv_wm_object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/riak&quot;&gt;riak_kv_wm_object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/types&quot;&gt;riak_kv_wm_object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/ping&quot;&gt;riak_kv_wm_ping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/buckets&quot;&gt;riak_kv_wm_props&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/types&quot;&gt;riak_kv_wm_props&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/stats&quot;&gt;riak_kv_wm_stats&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/search&quot;&gt;yz_wm_extract&lt;/a&gt;&lt;/li&gt;```
</code></pre>
<h2 id="whats-going-on">What’s Going On</h2>
<p>Our Vagrantfile looks like this:</p>
<pre class="hljs"><code>&lt;code class=&quot;ruby&quot; style=&quot;overflow-x:auto&quot;&gt;# -*- mode: ruby -*-
# vi: set ft=ruby :

VAGRANTFILE_API_VERSION = &quot;2&quot;
NUM_RIAK_NODES = 5

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = &quot;saucy-amd&quot;

  config.vm.define &quot;web&quot; do |web|
    web.vm.network &quot;private_network&quot;,
      ip: &quot;192.168.50.2&quot;, virtualbox__intnet: &quot;riakhaskellnetwork&quot;
    web.vm.provision &quot;shell&quot;, path: &quot;vagrant-files/haskell-build.sh&quot;
    web.vm.provider &quot;virtualbox&quot; do |v|
      v.memory = 1024
    end
  end

  config.vm.define &quot;haproxy&quot; do |ha|
    ha.vm.network &quot;private_network&quot;,
      ip: &quot;192.168.50.3&quot;, virtualbox__intnet: &quot;riakhaskellnetwork&quot;
    ha.vm.provision &quot;shell&quot;, path: &quot;vagrant-files/haproxy-build.sh&quot;
  end

# Base node is 192.168.50.10
# Subsequent nodes are .11/.12/etc
  (1..NUM_RIAK_NODES).each do |i|
    config.vm.define &quot;riak#{i}&quot; do |riakx|
      riakx.vm.network &quot;private_network&quot;,
        ip: &quot;192.168.50.#{i+9}&quot;, virtualbox__intnet: &quot;riakhaskellnetwork&quot;
      riakx.vm.provision &quot;shell&quot;, path: &quot;vagrant-files/riak-build.sh&quot;, args: &quot;192.168.50.#{i+9} 192.168.50.10&quot;
    end
  end
end```

Each of our vm types is defined in a `config.vm.define` block. We have `web`, `haproxy` and some `riak` nodes.

### Global

In each block we define a `private_network` named `riakhaskellnetwork` and define the IP addresses for each vm. `web` is `x.x.x.2`, `haproxy` is `x.x.x.3` and the `riak` nodes autoincrement from `x.x.x.10`. (riak1 is x.x.x.10, riak2 is x.x.x.11, etc)

### web

Our web vm is provisioned using the shell script located in `vagrant-files/haskell-build.sh`. It’s fairly basic and just installs the `haskell-platform` and updates `cabal`.

</code></pre>
<p><code class="bash" style="overflow-x:auto">echo &quot;Haskell 7.6.3&quot;
apt-get update
apt-get install build-essential haskell-platform -y
cabal update
cabal install cabal-install```</p>
<p>After <code>vagrant up web</code> we can <code>vagrant ssh web</code> and run <code>ghci</code> to start a Haskell interpreter.</p>
<h3 id="haproxy">haproxy</h3>
<p>Our HAProxy vm is a little more interesting. We install <code>haproxy</code>, set the open files limit to &gt; 256000 (in this case 266000) and then we start <code>haproxy</code> with the config file <code>vagrant-files/haproxy.config</code>. Note that there are no startup scripts, so this won’t to be able to withstand <code>vagrant reload</code> without running <code>vagrant provision</code> after it.</p>
<pre class="hljs"><code>&lt;code class=&quot;bash&quot; style=&quot;overflow-x:auto&quot;&gt;echo &quot;Building HAProxy&quot;
apt-get update
apt-get install haproxy -y
ulimit -n 266000
haproxy -V -f /vagrant/vagrant-files/haproxy.config```

If we check out `vagrant-files/haproxy.config` we can see a little about what we’re doing with our load balancer:

</code></pre>
<p><code class="config" style="overflow-x:auto">global
log 192.168.50.3     local0
log 192.168.50.3     local1 notice
maxconn           256000
chroot            /var/lib/haproxy
user              haproxy
group             haproxy
spread-checks     5
daemon
quiet</p>
<p>defaults
log               global
option            dontlognull
option            redispatch
option            allbackups
maxconn           256000
timeout connect   5000</p>
<p>backend riak_rest_backend
mode               http
balance            roundrobin
option             httpchk GET /ping
option             httplog
server riak1 192.168.50.10:8098 weight 1 maxconn 1024  check
server riak2 192.168.50.11:8098 weight 1 maxconn 1024  check
server riak3 192.168.50.12:8098 weight 1 maxconn 1024  check
server riak4 192.168.50.13:8098 weight 1 maxconn 1024  check
server riak5 192.168.50.14:8098 weight 1 maxconn 1024  check</p>
<p>frontend riak_rest
bind               192.168.50.3:8098
mode               http
option             contstats
default_backend    riak_rest_backend</p>
<p>backend riak_protocol_buffer_backend
balance            leastconn
mode               tcp
option             tcpka
option             srvtcpka
server riak1 192.168.50.10:8087 weight 1 maxconn 1024  check
server riak2 192.168.50.11:8087 weight 1 maxconn 1024  check
server riak3 192.168.50.12:8087 weight 1 maxconn 1024  check
server riak4 192.168.50.13:8087 weight 1 maxconn 1024  check
server riak5 192.168.50.14:8087 weight 1 maxconn 1024  check</p>
<p>frontend riak_protocol_buffer
bind               192.168.50.3:8087
mode               tcp
option             tcplog
option             contstats
mode               tcp
option             tcpka
option             srvtcpka
default_backend    riak_protocol_buffer_backend```</p>
<p>We are binding to the IP address of our vm, <code>192.168.50.3</code> and we’ve hardcoded the five node Riak cluster into our backends. We have a backend (the Riak nodes) and a frontend (webserver side) for Riak’s HTTP and Protobuf APIs.</p>
<h3 id="riakx">riakx</h3>
<p>The Riak nodes are provisioned by <code>vagrant-files/riak-build</code>. We cycle through a list from 1 to <code>NUM_RIAK_NODES</code> (in this case, 5), and create a node for each. We pass two arguments to our shell script for each node. One is the base node IP (always x.x.x.10) and the other is the current node’s IP.</p>
<pre class="hljs"><code>&lt;code class=&quot;config&quot; style=&quot;overflow-x:auto&quot;&gt;#!/bin/bash
# $2 is base riak node IP
# $1 is current node's IP
echo &quot;Building Riak Vagrant Node&quot;
echo $2
echo $1
sudo apt-get update
sudo apt-get install libssl0.9.8 default-jre -y
wget http://s3.amazonaws.com/downloads.basho.com/riak/2.0/2.0.0pre11/ubuntu/precise/riak_2.0.0pre11-1_amd64.deb
sudo dpkg -i riak_2.0.0pre11-1_amd64.deb
sed -i &quot;s/127.0.0.1/$1/g&quot; /etc/riak/riak.conf
sed -i 's/search = off/search = on/g' /etc/riak/riak.conf
ulimit -n 8192
riak start
if [[ &quot;$2&quot; != &quot;$1&quot; ]]
then
  echo &quot;Joining Base Riak Node $2&quot;
  riak-admin cluster join riak@$2
  riak-admin cluster plan
  riak-admin cluster commit
else
  echo &quot;Starting Base Riak Node&quot;
fi
echo $(riak-admin status | grep ring_members)```

1. We install libssl and a JRE (because we want to run Riak Search)
2. wget the `amd64.deb` for Riak2.0.0-pre11
3. install the .deb
4. Replace 127.0.0.1 with our node’s IP address
5. Replace `search = off` with `search = on` to turn on Riak Search
6. Set the file limit to 8192
7. Start Riak
8. then, if we have the base node, do nothing
9. If we have the non-base node, we commit a cluster plan to join with the base node
10. Finally, echo the result of `riak-admin status | grep ring_members`

Note that, just like the HAProxy vm, the Riak nodes don’t have init scripts and will need a `vagrant provision` after a `vagrant reload`


# Future Work

In the future I might include Riak CS in this configuration. In addition, it would be nice to have some init scripts to make for a more stable cluster. As it stands now, we have a pseudo-production configuration and we can examine the results of doing insane things like randomly `vagrant destroy`ing Riak nodes.

Now that I think about it, a chaos monkey would be a cool addition to this setup.
</code></pre>
</div></div></div></div></div></div><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-46878058-1', 'auto');
          ga('send', 'pageview');</script></body></html>