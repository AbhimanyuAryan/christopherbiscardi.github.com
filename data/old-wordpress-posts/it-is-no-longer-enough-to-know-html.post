---
title: "It Is No Longer Enough to \"know\" HTML"
date: "Sun, 28 Sep 2014 13:57:27 +0000"
layout: post
path: "/2014/9/28/it-is-no-longer-enough-to-know-html/"
---


> “Life moves pretty fast. If you don’t stop and look around for a while, you could miss it.” – Ferris Bueller’s Day Off

### The State of Front End Development

Front End tools are moving fast these days. Let’s take a minute to (briefly) look at where we’re going.

### Module Systems

### The Old Way

From a user-facing view, the old way is to wrap code in closures.

```
(function () {
   this.myGlobal = function () {};
}());
```

#### AMD

[Why AMD?](http://requirejs.org/docs/whyamd.html) is covered in other areas but suffice it to say it looks like the below and is being superseded by the ubiquity and conciseness of CommonJS.

```
define(['jquery'] , function ($) {
    return function () {};
});
```

#### CommonJS

CommonJS is used in node.js which likely contributed to its rise. It is also fairly simple to read and understand. There isn’t as much boilerplate as AMD (where the define/arguments are position-sensitive and can get fairly long).

```
// hello.js
exports.hello = function() {
  return 'Hello World'
};
```

```
// main.js
var example = require('./hello.js');
example.hello();
```

#### ES6

ES6 modules are usable via transpilers, in some cases [compiling to CommonJS](https://www.npmjs.org/package/es6-modules-commonjs)

```
module React from "react";
import {format} from "util";
export {React, format as fmt};
```

#### PureScript

PureScript [modules](http://docs.purescript.org/en/latest/modules.html) can compile to CommonJS modules.

```
module A where

id x = x
```

### Implementations of Module Systems

#### RequireJS

[RequireJS](http://requirejs.org/) is an implementation of AMD. It comes with an optimizer (r.js) but many people have since moved on to CommonJS tools such as Browserify.

#### Browserify

[Browserify](http://browserify.org/) is currently the prevailing CommonJS implementation. It is available as a CLI and a scriptable interface (say, inside node.js). This makes it easy to integrate into a build system such as gulp or to use on it’s own.

Browserify allows you to apply transforms during the build process for things like [React](https://www.npmjs.org/package/reactify), [bower](https://github.com/eugeneware/debowerify) and alt-js languages such as [CoffeeScript](https://github.com/jnordberg/coffeeify).

#### Webpack

[Webpack](http://webpack.github.io/) sees heavy usage in the React Community. Possibly due to Pete Hunt’s (and others’) [advocacy](https://github.com/petehunt/webpack-howto). Webpack comes with nice things like Feature Flags and Multiple Entrypoints.

The most striking difference between Webpack and Browserify is the approach to building Components. Webpack takes a much more CSS-inclusive approach and can do dependency analysis if you’re using Multiple Entrypoints or similar. This approach to Components works very well with React’s concept of Components.

### Package Managers

#### NPM

[NPM](https://www.npmjs.org/) is the defacto standard for node.js, but has also declared support for front-end dependency management. It can be hard to determine what packages are meant for the browser, server or both.

#### Bower

Bower is a front-end dependency management tool that is backed by Git/GitHub. Bower is also where [PureScript](https://leanpub.com/purescript/read), an alt-js language, and some other tools make their packages available.

#### Other

There are also other, competing, managers at various levels such as [Volo](http://volojs.org/) and [Ender](https://github.com/ender-js/Ender)

…but talking about Volo brings us into scaffolding tools…

### Scaffolding

#### Yeoman

[Yeoman](http://yeoman.io/) was originally a “Client Side Stack” but has transitioned to being a quite nice tool for scaffolding new projects. I suggest [this one](https://github.com/yeoman/generator-gulp-webapp) if you’re looking to learn more about Yeoman.

#### Brunch

I chose to include [Brunch](http://brunch.io/) here even though it also competes with Gulp/Grunt in that Brunch does Compilation, Minification, Concatenation and Watching of files. IMO Brunch tries to do too much in the world of JavaScript today. Specialized tools seem to be the current order.

### Build Systems

#### Grunt

[Grunt](http://gruntjs.com/) is a Task Runner for JavaScript. It works fairly well and has a plugin for almost anything you’ll need; I’ve also seen some pretty hairy grunt configs.

[Gulp](http://gulpjs.com/) is “The New Order” of build systems. It is based on streaming so we can say goodbye to intermediate build files on disk. It also has a fairly expansive ecosystem of plugins that can be used. One interesting note is [vinyl-source-streams](https://www.npmjs.org/package/vinyl-source-stream), which can be used to create streams out of tools like browserify.

### Utility Belts

#### Underscore

[Underscore](http://underscorejs.org/) was a default utility belt for awhile. It is a solid library that provides functional programming helpers and is:

> The tie to go along with jQuery’s tux and Backbone’s suspenders.

#### Lodash

[Lodash](http://lodash.com/) is “optimized underscore”. It is capable of being a drop-in replacement for underscore and provides [some features](http://lodash.com/#features) not available in underscore.

#### Lazy.js

[Lazy.js](http://danieltao.com/lazy.js/) can get even better performance than Lodash through Lazy Evaluation. It seems to be a logical step in the progression toward the new state of Front End JavaScript.

### Data Structures

One very interesting trend to pop up is the release of Lazy and Immutable Data Structures for JavaScript. Often the assumption here is that what makes FE development difficult is the tracking of mutation and maintaining of State.

#### Mori

[Mori](https://github.com/swannodette/mori) is Om/ClojureScript’s Lazy/Persistent/Immutable Data Structures intended for use in a JavaScript environment.

#### ImmutableJS

[ImmutableJS](https://github.com/facebook/immutable-js) is Facebook’s implementation of Immutable and Lazy Data Structures. It uses a JavaScript-First API and is designed with the context of React and Flux (being from Facebook).

### Front End Frameworks

Finally, we come to “The Large List of Front End Frameworks”. There are a *ton* of them out there but I’m only going to cover a few of the most popular in an attempt to categorize different approaches.

#### Angular: The Opinionated Approach

Angular creates it’s own language in an effort to do a lot. Directives help developers create components and Services abstract data fetching. If you are a fan of Dependency Injection, Factories and Controllers, then you may do well to look at Angular.

#### Backbone: The Dude Abides

Backbone is fairly un-opinionated. `Models`/`Collection`, `Views` and `Routers` live here, which is fairly close to “MVC”. Backbone also includes an event system for listening to changes on Models/Collections or creating your own events.

Backbone’s flexibility has allowed (or required depending on your view) [Marionette](http://marionettejs.com/) to exist. It also means that you can replace any component as you wish. Want to use Handlebars? Mustache? no problem. Want to replace `Views` with React? no problem.

#### React

React is the new kid on the block and represents a substantial change in the way people think about building applications. With pure React, you would never manually adjust the DOM again. Instead allowing React’s implementation of a Virtual DOM to handle diffing and insertion of changes into the actual DOM.

React also represents a step toward Functional Programming concepts ([purity](http://en.wikipedia.org/wiki/Pure_function), etc), which make React components easy to test and reason about. It also enables some more advanced concepts such as [Cursors](https://github.com/dustingetz/react-cursor) or [Lenses](http://lens.github.io/tutorial.html) which themselves enable a separation of data from View/DOM.

#### Om

[Om](https://github.com/swannodette/om) is a special case of React. It is implemented in [ClojureScript](https://github.com/clojure/clojurescript), uses some concepts such as [Worlds](http://www.vpri.org/pdf/tr2011001_final_worlds.pdf) and Persistent Data Structures and has a fairly expansive ecosystem at this point.

There is a [list](https://github.com/swannodette/om#applications-built-with-om) of projects built with Om.

### The Types are Coming

So where does this leave us?

Even if we leave out React/Om we can see a clear preference towards Functions as a first-class tool through libraries such as Underscore and Lodash. *With* React, we get to see where functional programming gets us, The testability of pure functions and the composition of Components (which are themselves functions). With Om, we see where more advanced Functional Programming techniques gets us: Performance from Persistent Data Structures and clarity through separation of IO with Worlds.

At this point it is interesting to note is that React was prototyped in SML and [Flow](https://twitter.com/fbOpenSource/status/511643210482208768) is implemented in [OCaml](https://ocaml.org/). Flow promises to be “better” (note that not much is known about Flow publicly yet) than Microsoft’s [TypeScript](http://www.typescriptlang.org/). We’ll have to wait to see how it compares to [PureScript’s](https://leanpub.com/purescript/read) Type System. (PureScript does have [bindings to React](https://github.com/purescript-contrib/purescript-react) as well).


# Fin

If I were a betting person, I would bet on the future being closer to a Purely Functional approach than I would on other approaches. What do you think?

In any case, The days where one could cobble together some HTML and call themselves a Front End Engineer are long gone and the future is very interesting.


