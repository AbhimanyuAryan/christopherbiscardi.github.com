<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title data-react-helmet="true">Servant Custom Content Types</title><meta data-react-helmet="true" property="description" content="Recently when implementing a Docker Registry I came across the need to
hash the incoming request body in a way that matches the…"/><meta data-react-helmet="true" property="og:title" content="Servant Custom Content Types"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:url" content="http://christopherbiscardi.com/servant-custom-content-types/"/><meta data-react-helmet="true" property="og:description" content="Recently when implementing a Docker Registry I came across the need to
hash the incoming request body in a way that matches the…"/><meta data-react-helmet="true" property="og:image" content="http://christopherbiscardi.com/4697ea4ccbcd2ba2f293936baed59b9d.png"/><meta data-react-helmet="true" property="twitter:card" content="summary"/><meta data-react-helmet="true" property="twitter:title" content="Servant Custom Content Types"/><meta data-react-helmet="true" property="twitter:description" content="Recently when implementing a Docker Registry I came across the need to
hash the incoming request body in a way that matches the…"/><meta data-react-helmet="true" property="twitter:url" content="http://christopherbiscardi.com/servant-custom-content-types/"/><link rel="stylesheet" type="text/css" href="/styles.f25bf9e6682280946ba2e441a544b407.css"/></head><body class="landing-page"><div id="content"><div data-reactroot="" data-reactid="1" data-react-checksum="276531259"><div class="Nav__wrapper___u7BUA" data-reactid="2"><nav class="Nav__nav___1e2Pp" data-reactid="3"><a class="Nav__logoWrapper___35yvY" href="/" data-reactid="4"><img class="Nav__logo___sw4O9" src="/69305db2985e926d498b513a21d28383.png" data-reactid="5"/></a><ul class="Nav__items___1oDCD" data-reactid="6"><li data-reactid="7"><a class="Nav__itemLink___H6Isv" href="/posts/" data-reactid="8">Posts</a></li><li data-reactid="9"><a href="https://github.com/ChristopherBiscardi/ama/issues?q=is%3Aissue+is%3Aclosed" class="Nav__itemLink___H6Isv" data-reactid="10">AMA</a></li><li data-reactid="11"><a class="Nav__itemLink___H6Isv" href="/books/" data-reactid="12">Books</a></li><li data-reactid="13"><a class="Nav__itemLink___H6Isv" href="/projects/" data-reactid="14">Projects</a></li><li data-reactid="15"><a class="Nav__itemLink___H6Isv" href="/about/" data-reactid="16">About</a></li></ul></nav></div><div data-reactid="17"><div class="Post__page___15ves" data-reactid="18"><!-- react-empty: 19 --><div class="Post__container___f_rKX" data-reactid="20"><div class="Post__singleColumn___tYK8R" data-reactid="21"><h1 class="Post__title___2I6DZ" data-reactid="22">Servant Custom Content Types</h1><div class="Post__meta___1fVoc" data-reactid="23"><!-- react-text: 24 -->Oct 3rd, 2016<!-- /react-text --><!-- react-text: 25 --> · <!-- /react-text --><!-- react-text: 26 -->2<!-- /react-text --><!-- react-text: 27 --> minute read<!-- /react-text --></div></div></div><img class="Post__img___VXS1J" src="/4697ea4ccbcd2ba2f293936baed59b9d.png" data-reactid="28"/><div class="Post__container___f_rKX" data-reactid="29"><div class="Post__singleColumn___tYK8R" data-reactid="30"><div data-reactid="31"><p>Recently when implementing a Docker Registry I came across the need to
hash the incoming request body in a way that matches the clients
hash. Since the Docker engine is an existing client that speaks a
couple of different <code>Content-Type</code>s (such as
<code>application/vnd.docker.distribution.manifest.v2+json</code>, we cannot use
Servant’s alternate content types to get a ByteString to hash. This
leads us to one possible implementation, which is to create a new
content type that uses
<code>application/vnd.docker.distribution.manifest.v2+json</code> as the <code>Accept</code>
header, but also hashes the content body with <code>SHA256</code>. Our content
type will behave very similarly to <code>application/json</code>.</p>
<p>We will use <a href="https://hackage.haskell.org/package/cryptonite">cryptonite</a> for hashing and <a href="https://hackage.haskell.org/package/aeson">Aeson</a>
for JSON decoding. The full code follows.</p>
<pre class="highlight__hljs___FzKxy index__p2___65FBl"><code><span class="hljs-meta">{-# LANGUAGE FlexibleInstances     #-}</span>
<span class="hljs-meta">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="hljs-meta">{-# LANGUAGE OverloadedStrings     #-}</span>
<span class="highlight__hljs-keyword___som98">module</span> SR.HashedJSONContentType <span class="highlight__hljs-keyword___som98">where</span>

<span class="highlight__hljs-keyword___som98">import</span>           Crypto.Hash                (<span class="highlight__hljs-type___11WfV">Digest</span>, <span class="highlight__hljs-type___11WfV">SHA256</span>)
<span class="highlight__hljs-keyword___som98">import</span>           Data.Aeson
<span class="highlight__hljs-keyword___som98">import</span> <span class="highlight__hljs-keyword___som98">qualified</span> Data.ByteString.Lazy.Char8 <span class="highlight__hljs-keyword___som98">as</span> BSC
<span class="highlight__hljs-keyword___som98">import</span>           Network.HTTP.Media         <span class="highlight__hljs-keyword___som98">hiding</span> (<span class="highlight__hljs-type___11WfV">Accept</span>)
<span class="highlight__hljs-keyword___som98">import</span>           Servant.API.ContentTypes

<span class="highlight__hljs-keyword___som98">import</span>           Utils                      (<span class="highlight__hljs-title___1fl8Q">mkDigest</span>)

<span class="highlight__hljs-class___mOeOV"><span class="highlight__hljs-keyword___som98">data</span> <span class="highlight__hljs-type___11WfV">HashedJSON</span> = <span class="highlight__hljs-type___11WfV">HashedJSON</span> <span class="highlight__hljs-type___11WfV">String</span></span>
<span class="highlight__hljs-class___mOeOV">
<span class="highlight__hljs-keyword___som98">instance</span> <span class="highlight__hljs-type___11WfV">Accept</span> <span class="highlight__hljs-type___11WfV">HashedJSON</span> <span class="highlight__hljs-keyword___som98">where</span></span>
  contentType _ = <span class="highlight__hljs-string___1SffY">"application"</span> // <span class="highlight__hljs-string___1SffY">"vnd.docker.distribution.manifest.v2+json"</span>

<span class="highlight__hljs-comment___UYk12">-- | We don't need MimeRender for this since we are only using </span>
<span class="highlight__hljs-comment___UYk12">--   the content-type for receiving data.</span>
<span class="highlight__hljs-comment___UYk12">-- instance Show a =&gt; MimeRender HashedJSON a where</span>
<span class="highlight__hljs-comment___UYk12">--    mimeRender _ val = pack ("This is MINE! " ++ show val)</span>
<span class="highlight__hljs-class___mOeOV">
<span class="highlight__hljs-keyword___som98">instance</span> <span class="highlight__hljs-type___11WfV">FromJSON</span> a =&gt; <span class="highlight__hljs-type___11WfV">MimeUnrender</span> <span class="highlight__hljs-type___11WfV">HashedJSON</span> (<span class="highlight__hljs-type___11WfV">Digest</span> <span class="highlight__hljs-type___11WfV">SHA256</span>, <span class="highlight__hljs-title___1fl8Q">a</span>) <span class="highlight__hljs-keyword___som98">where</span></span>
   mimeUnrender _ bs = <span class="highlight__hljs-keyword___som98">case</span> eitherDecodeLenient bs <span class="highlight__hljs-keyword___som98">of</span>
     <span class="highlight__hljs-type___11WfV">Left</span> err -&gt; <span class="highlight__hljs-type___11WfV">Left</span> err
     <span class="highlight__hljs-type___11WfV">Right</span> val -&gt; <span class="highlight__hljs-type___11WfV">Right</span> (mkDigest $ <span class="highlight__hljs-type___11WfV">BSC</span>.toStrict bs, val)
</code></pre>
<p>The most interesting part is the <code>MimeUnrender</code> instance for our
custom content type <code>HashedJSON</code>. Servant provides a more lenient
version of Aeson’s <code>decode</code> called <code>eitherDecodeLenient</code>. We use this
for compatibility with the normal <code>'JSON</code> content type in Servant.</p>
<p>The instance uses a tuple <code>(Digest SHA256, a)</code> so any route types we
write in the future will look similar to the following code which uses
a fake type <code>OurType</code>.</p>
<pre class="highlight__hljs___FzKxy index__p2___65FBl"><code><span class="highlight__hljs-type___11WfV">ReqBody</span> '[<span class="highlight__hljs-type___11WfV">HashedJSON</span>] (<span class="highlight__hljs-type___11WfV">Digest</span> <span class="highlight__hljs-type___11WfV">SHA256</span>, <span class="highlight__hljs-type___11WfV">OurType</span>) 
</code></pre>
<p>An example handler using the above <code>ReqBody</code> declaration follows.</p>
<pre class="highlight__hljs___FzKxy index__p2___65FBl"><code><span class="highlight__hljs-title___1fl8Q">putManifest</span> :: (<span class="highlight__hljs-type___11WfV">CH</span>.<span class="highlight__hljs-type___11WfV">Digest</span> <span class="highlight__hljs-type___11WfV">CH</span>.<span class="highlight__hljs-type___11WfV">SHA256</span>, <span class="highlight__hljs-type___11WfV">Manifest</span>) -&gt; <span class="highlight__hljs-type___11WfV">App</span> <span class="highlight__hljs-type___11WfV">NoContent</span>)
<span class="highlight__hljs-title___1fl8Q">putManifest</span> (digest, manifest) = <span class="highlight__hljs-keyword___som98">do</span>
  <span class="highlight__hljs-comment___UYk12">-- do stuff with digests and manifests</span>
  return <span class="highlight__hljs-type___11WfV">NoContent</span>
</code></pre>
<p>One can envision how changing the type of the hash in the type might
allow us to specify which algorithm we want to use in the same way
that we specify <code>Manifest</code>.</p>
</div></div></div></div></div></div></div><script charset="UTF-8">window.__APOLLO_STATE__={"apollo":{"data":{"$ROOT_QUERY.root.post({\"slug\":\"servant-custom-content-types\"})":{"body":"<p>Recently when implementing a Docker Registry I came across the need to\nhash the incoming request body in a way that matches the clients\nhash. Since the Docker engine is an existing client that speaks a\ncouple of different <code>Content-Type</code>s (such as\n<code>application/vnd.docker.distribution.manifest.v2+json</code>, we cannot use\nServant’s alternate content types to get a ByteString to hash. This\nleads us to one possible implementation, which is to create a new\ncontent type that uses\n<code>application/vnd.docker.distribution.manifest.v2+json</code> as the <code>Accept</code>\nheader, but also hashes the content body with <code>SHA256</code>. Our content\ntype will behave very similarly to <code>application/json</code>.</p>\n<p>We will use <a href=\"https://hackage.haskell.org/package/cryptonite\">cryptonite</a> for hashing and <a href=\"https://hackage.haskell.org/package/aeson\">Aeson</a>\nfor JSON decoding. The full code follows.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"hljs-meta\">{-# LANGUAGE FlexibleInstances     #-}</span>\n<span class=\"hljs-meta\">{-# LANGUAGE MultiParamTypeClasses #-}</span>\n<span class=\"hljs-meta\">{-# LANGUAGE OverloadedStrings     #-}</span>\n<span class=\"highlight__hljs-keyword___som98\">module</span> SR.HashedJSONContentType <span class=\"highlight__hljs-keyword___som98\">where</span>\n\n<span class=\"highlight__hljs-keyword___som98\">import</span>           Crypto.Hash                (<span class=\"highlight__hljs-type___11WfV\">Digest</span>, <span class=\"highlight__hljs-type___11WfV\">SHA256</span>)\n<span class=\"highlight__hljs-keyword___som98\">import</span>           Data.Aeson\n<span class=\"highlight__hljs-keyword___som98\">import</span> <span class=\"highlight__hljs-keyword___som98\">qualified</span> Data.ByteString.Lazy.Char8 <span class=\"highlight__hljs-keyword___som98\">as</span> BSC\n<span class=\"highlight__hljs-keyword___som98\">import</span>           Network.HTTP.Media         <span class=\"highlight__hljs-keyword___som98\">hiding</span> (<span class=\"highlight__hljs-type___11WfV\">Accept</span>)\n<span class=\"highlight__hljs-keyword___som98\">import</span>           Servant.API.ContentTypes\n\n<span class=\"highlight__hljs-keyword___som98\">import</span>           Utils                      (<span class=\"highlight__hljs-title___1fl8Q\">mkDigest</span>)\n\n<span class=\"highlight__hljs-class___mOeOV\"><span class=\"highlight__hljs-keyword___som98\">data</span> <span class=\"highlight__hljs-type___11WfV\">HashedJSON</span> = <span class=\"highlight__hljs-type___11WfV\">HashedJSON</span> <span class=\"highlight__hljs-type___11WfV\">String</span></span>\n<span class=\"highlight__hljs-class___mOeOV\">\n<span class=\"highlight__hljs-keyword___som98\">instance</span> <span class=\"highlight__hljs-type___11WfV\">Accept</span> <span class=\"highlight__hljs-type___11WfV\">HashedJSON</span> <span class=\"highlight__hljs-keyword___som98\">where</span></span>\n  contentType _ = <span class=\"highlight__hljs-string___1SffY\">\"application\"</span> // <span class=\"highlight__hljs-string___1SffY\">\"vnd.docker.distribution.manifest.v2+json\"</span>\n\n<span class=\"highlight__hljs-comment___UYk12\">-- | We don't need MimeRender for this since we are only using </span>\n<span class=\"highlight__hljs-comment___UYk12\">--   the content-type for receiving data.</span>\n<span class=\"highlight__hljs-comment___UYk12\">-- instance Show a =&gt; MimeRender HashedJSON a where</span>\n<span class=\"highlight__hljs-comment___UYk12\">--    mimeRender _ val = pack (\"This is MINE! \" ++ show val)</span>\n<span class=\"highlight__hljs-class___mOeOV\">\n<span class=\"highlight__hljs-keyword___som98\">instance</span> <span class=\"highlight__hljs-type___11WfV\">FromJSON</span> a =&gt; <span class=\"highlight__hljs-type___11WfV\">MimeUnrender</span> <span class=\"highlight__hljs-type___11WfV\">HashedJSON</span> (<span class=\"highlight__hljs-type___11WfV\">Digest</span> <span class=\"highlight__hljs-type___11WfV\">SHA256</span>, <span class=\"highlight__hljs-title___1fl8Q\">a</span>) <span class=\"highlight__hljs-keyword___som98\">where</span></span>\n   mimeUnrender _ bs = <span class=\"highlight__hljs-keyword___som98\">case</span> eitherDecodeLenient bs <span class=\"highlight__hljs-keyword___som98\">of</span>\n     <span class=\"highlight__hljs-type___11WfV\">Left</span> err -&gt; <span class=\"highlight__hljs-type___11WfV\">Left</span> err\n     <span class=\"highlight__hljs-type___11WfV\">Right</span> val -&gt; <span class=\"highlight__hljs-type___11WfV\">Right</span> (mkDigest $ <span class=\"highlight__hljs-type___11WfV\">BSC</span>.toStrict bs, val)\n</code></pre>\n<p>The most interesting part is the <code>MimeUnrender</code> instance for our\ncustom content type <code>HashedJSON</code>. Servant provides a more lenient\nversion of Aeson’s <code>decode</code> called <code>eitherDecodeLenient</code>. We use this\nfor compatibility with the normal <code>'JSON</code> content type in Servant.</p>\n<p>The instance uses a tuple <code>(Digest SHA256, a)</code> so any route types we\nwrite in the future will look similar to the following code which uses\na fake type <code>OurType</code>.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"highlight__hljs-type___11WfV\">ReqBody</span> '[<span class=\"highlight__hljs-type___11WfV\">HashedJSON</span>] (<span class=\"highlight__hljs-type___11WfV\">Digest</span> <span class=\"highlight__hljs-type___11WfV\">SHA256</span>, <span class=\"highlight__hljs-type___11WfV\">OurType</span>) \n</code></pre>\n<p>An example handler using the above <code>ReqBody</code> declaration follows.</p>\n<pre class=\"highlight__hljs___FzKxy index__p2___65FBl\"><code><span class=\"highlight__hljs-title___1fl8Q\">putManifest</span> :: (<span class=\"highlight__hljs-type___11WfV\">CH</span>.<span class=\"highlight__hljs-type___11WfV\">Digest</span> <span class=\"highlight__hljs-type___11WfV\">CH</span>.<span class=\"highlight__hljs-type___11WfV\">SHA256</span>, <span class=\"highlight__hljs-type___11WfV\">Manifest</span>) -&gt; <span class=\"highlight__hljs-type___11WfV\">App</span> <span class=\"highlight__hljs-type___11WfV\">NoContent</span>)\n<span class=\"highlight__hljs-title___1fl8Q\">putManifest</span> (digest, manifest) = <span class=\"highlight__hljs-keyword___som98\">do</span>\n  <span class=\"highlight__hljs-comment___UYk12\">-- do stuff with digests and manifests</span>\n  return <span class=\"highlight__hljs-type___11WfV\">NoContent</span>\n</code></pre>\n<p>One can envision how changing the type of the hash in the type might\nallow us to specify which algorithm we want to use in the same way\nthat we specify <code>Manifest</code>.</p>\n","attributes":{"type":"id","id":"$ROOT_QUERY.root.post({\"slug\":\"servant-custom-content-types\"}).attributes","generated":true},"__typename":"BlogPost"},"$ROOT_QUERY.root.post({\"slug\":\"servant-custom-content-types\"}).attributes":{"title":"Servant Custom Content Types","updatedAt":"Oct 3rd, 2016","publishedAt":"Oct 3rd, 2016","timeToRead":2,"headerImage":"/4697ea4ccbcd2ba2f293936baed59b9d.png","url":"/servant-custom-content-types/","canonicalURL":null,"excerpt":"Recently when implementing a Docker Registry I came across the need to\nhash the incoming request body in a way that matches the…","__typename":"BlogPostAttributes"},"$ROOT_QUERY.root":{"post({\"slug\":\"servant-custom-content-types\"})":{"type":"id","id":"$ROOT_QUERY.root.post({\"slug\":\"servant-custom-content-types\"})","generated":true},"__typename":"Query"},"ROOT_QUERY":{"root":{"type":"id","id":"$ROOT_QUERY.root","generated":true}}}}};</script><script src="/js/client.js" charset="UTF-8"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-46878058-1', 'auto');
          ga('send', 'pageview');</script></body></html>